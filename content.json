{"meta":{"title":"Vollate's Blog","subtitle":"","description":"Personal blog","author":"Vollate","url":"http://blog.vollate.top","root":"/"},"pages":[{"title":"About Me","date":"2023-08-31T03:48:42.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.vollate.top/about/index.html","excerpt":"","text":"头像来源：CorelDRAW 的一种默认图案填充，原因是 不想被当成傻逼二次元 在不知道该用什么好的情况下随手截的 代码偏好 语言: C++, Rust, ShellScript, Python, JAVA, Go, ECMAScript, C GNU/Linux 发行版: Arch, Debian, NixOS 编辑器: Vim, Jetbrains IDE, VScode 爱好 看番, 轻小说 养老 fps 选手，底力不足音游人，旮旯给木玩家 睡觉 車万(一度非常喜欢，但是现在热情淡了) 目标 有一个健康的作息 锻炼身体 好好活着 Painted by shnva"},{"title":"links","date":"2023-08-31T03:48:42.000Z","updated":"2023-08-31T03:48:42.000Z","comments":true,"path":"links/index.html","permalink":"http://blog.vollate.top/links/index.html","excerpt":"","text":""},{"title":"Repository","date":"2023-08-31T03:48:42.000Z","updated":"2023-12-15T08:54:40.000Z","comments":false,"path":"repository/index.html","permalink":"http://blog.vollate.top/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-31T03:48:42.000Z","updated":"2023-08-31T03:48:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.vollate.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-08-31T03:48:42.000Z","updated":"2023-08-31T03:48:42.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.vollate.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"记 Singbox Google Play 连接问题解决","slug":"singbox-google-play-error","date":"2025-07-14T15:29:10.000Z","updated":"2025-07-14T17:20:53.000Z","comments":true,"path":"2025/07/14/singbox-google-play-error/","permalink":"http://blog.vollate.top/2025/07/14/singbox-google-play-error/","excerpt":"","text":"问题描述 自从电脑从 clash verge rev 换到 Singbox 并且配置好自己的 doh3 dns server 后，手机上的代理软件也从 Surfboard 换成的 Singbox 的安卓版并导入电脑上配置好的配置文件。导入之后一切安好，除了 Google Play 商店无法下载，永远卡在转圈。开了 global 模式后，问题解决，因此是规则配置的问题。 不得不说，安卓版 UI 非常简陋，单纯做了个壳子。能用，也仅限能用。log 输出非常不友好，也没有暂停按键，开 debug level 后 log 刷新速度非常快，不是人能看的。不过通过 clash api, 我们可以远程获取到 log 信息。 获取 log 首先连接手机并启用 usb debug，电脑上执行 adb forward tcp:&lt;pc-port&gt; tcp:&lt;phone-port&gt; 将手机上 clash api 的端口转发到电脑上，然后通过浏览器访问 http://localhost:&lt;pc-port&gt; 就可以调用了。 web ui 一开始尝试使用 yacd,但是发现 log 输出花里胡哨难以复制并分析，换了 Dreamacro/clash-dashboard 后好多了。 问题分析 截取了使用 clash Rule mode 和 Global mode 的 log 信息，对照后问题如下 1234567# ——— Rule mode ———[3517687682 …] inbound … to services.googleapis.cn:443[3517687682 …] outbound/direct[🎯 Direct]: outbound connection to services.googleapis.cn:443# ——— 切到 Global 模式 后 ———[4166616312 …] inbound … to services.googleapis.cn:443[4166616312 …] outbound/vless[这是马赛克(]: outbound connection to services.googleapis.cn:443 查询后发现是 services.googleapis.cn 的返回导致之后的下载链接到的是 google play cn 的域名，显而易见无法连接(。将 services.googleapis.cn 路由规则改为走代理后，问题解决。 疑问 那么问题来了，为什么即使开了 global 模式，还是会去走 cn 的域名呢。查询后发现是 GMS 会对手机 SIM 卡的 MCC/MNC 码进行判断。当 MCC 为 460 时，GMS 就将设备标记为“中国大陆用户”。触发 GMS 内部一个写死的（硬编码的）规则。这个规则将标准的 Google 服务域名（如 *.googleapis.com, *.gstatic.com）直接在客户端层面就替换为中国专用的域名（*.googleapis.cn, *.gstatic.cn）。 笔者刚好有一张旅游办的海外电话卡，拔掉国内卡并插上后，重新检查 Singbox log，发现请求域名变成了 firebaselogging.googleapis.com，验证了上述原因。 好久没写这种问题记录 blog 了，主要感觉没什么技术含量，而且写起来的时间成本太高，比解决问题的时间还长（ 不过还是有用的，至少写 blog 会让你想去挖一下问题背后的原因而不是解决了就完事(人肉 AI Agent)，不过还是好水","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Singbox","slug":"Singbox","permalink":"http://blog.vollate.top/tags/Singbox/"},{"name":"Android","slug":"Android","permalink":"http://blog.vollate.top/tags/Android/"}]},{"title":"Clash 迁移到 Sing-Box","slug":"clash2singbox","date":"2025-04-26T10:31:17.000Z","updated":"2025-04-26T19:12:34.000Z","comments":true,"path":"2025/04/26/clash2singbox/","permalink":"http://blog.vollate.top/2025/04/26/clash2singbox/","excerpt":"","text":"很早以前就了解到 Sing-Box 了，但是人一直很懒，clash-verge-rev 配置没怎么改就懒得换（不得不提用 Tauri 写的 GUI 真的各种奇奇怪怪的问题）。今天爆了 service 提权漏洞，索性换到 Singbox 了。 Sing-Box 自身在桌面端没有成熟的 GUI，只有 CLI, 这里选用 GUI for Cores，支持多种 kernel。 Sing-box 作为重新实现的新内核，支持大多数代理协议，内存占用更低。同时没有 clash-* 那么多历史包袱并且完全开源，安全性更高。 安装 笔者的系统是 X64 Arch Linux，内核是 Linux 6.14.3-arch1-1,使用 NetworkManager 管理网络,防火墙是 firewalld。 作为 Arch 用户，最先尝试的肯定是 AUR 包了，装了发现并不是最新（2025-04-26)，看了下 Github 上的二进制 release 内置滚动更新，直接下载了二进制包。 单独创建一个目录解压后丢进去，配置照着官方文档就行了。 问题&amp;解决 防火墙放行 tun 设备 和mihomo(clash-meta)不同，singbox 注册 tun 设备的方式是通过 netlink 的方式注册的，这就导致 NetworkManager 会自动将其注册为一个新的 Connection 而不是 mihomo 的 interface 设备，每次的 uuid 会变化，无法设置 firewalld zone 规则。 解决方法是在 /etc/NetworkManager/conf.d/ 目录下创建一个&quot;xxx.config&quot;配置文件: [keyfile]unmanaged-devices=interface-name:&lt;Your tun interface name&gt; 将 &lt;Your tun interface name&gt; 替换为你实际的 tun 设备名称,这个在 Singbox 的配置文件中可以找到，如果是 GUI for singbox 则是在的 profile中配置（记得启用），然后重新加载 NetworkManager: systemctl reload NetworkManager 然后在 firewalld 中添加规则并重启: firewall-cmd --permanent --zone=trusted --add-interface=&lt;Your tun interface name&gt;firewall-cmd --reload 这样 NetworkManager 就不会管理这个设备尝试为其创建 Connection，firewalld 便可以根据 interface-name 设置 zone 规则了。","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Singbox","slug":"Singbox","permalink":"http://blog.vollate.top/tags/Singbox/"},{"name":"Proxy","slug":"Proxy","permalink":"http://blog.vollate.top/tags/Proxy/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"}]},{"title":"Systemd network-online.target 问题排查记录","slug":"systemd-network-online-problem","date":"2024-12-02T12:46:13.000Z","updated":"2024-12-02T12:46:31.000Z","comments":true,"path":"2024/12/02/systemd-network-online-problem/","permalink":"http://blog.vollate.top/2024/12/02/systemd-network-online-problem/","excerpt":"","text":"clash verge rev 某不存在的软件更新到 2.0 后，启动时会安装 systemd 服务用于 TUN 网络代理。但升级后每次都需要重新执行 uninstall-service 和 install-service, 且必定会卡死一段时间。这里记录一下排查过程。 检查为何要执行 uninstall-service 和 install-service 查看源码得知，service 安装由这个函数执行，检查调用他的 check_service 函数发现对 “SERVICE_URL/get_clash” 发 GET 请求来检测服务是否运行。 “SERVICE_URL” 是一个常量,为 “http://127.0.0.1:33211” lsof 看看是什么进程 123456789101112131415161718192021222324252627❯ sudo lsof -i :33211COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEclash-ver 738 root 9u IPv4 5515 0t0 TCP localhost:33211 (LISTEN)❯ sudo lsof -p 738lsof: WARNING: can&#x27;t stat() fuse.portal file system /run/user/1001/doc Output information may be incomplete.COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEclash-ver 738 root cwd DIR 259,6 4096 2 /clash-ver 738 root rtd DIR 259,6 4096 2 /clash-ver 738 root txt REG 259,6 1068272 4667021 /usr/bin/clash-verge-serviceclash-ver 738 root mem REG 259,6 2014520 4590980 /usr/lib/libc.so.6clash-ver 738 root mem REG 259,6 14280 4590996 /usr/lib/libdl.so.2clash-ver 738 root mem REG 259,6 973144 4591006 /usr/lib/libm.so.6clash-ver 738 root mem REG 259,6 14288 4591034 /usr/lib/libpthread.so.0clash-ver 738 root mem REG 259,6 14352 4591039 /usr/lib/librt.so.1clash-ver 738 root mem REG 259,6 915712 4591699 /usr/lib/libgcc_s.so.1clash-ver 738 root mem REG 259,6 228376 4590929 /usr/lib/ld-linux-x86-64.so.2clash-ver 738 root 0r CHR 1,3 0t0 4 /dev/nullclash-ver 738 root 1u unix 0x000000005430ea85 0t0 17938 type=STREAM (CONNECTED)clash-ver 738 root 2u unix 0x000000005430ea85 0t0 17938 type=STREAM (CONNECTED)clash-ver 738 root 3u a_inode 0,16 0 2087 [eventpoll:4,8,9]clash-ver 738 root 4u a_inode 0,16 0 2087 [eventfd:0]clash-ver 738 root 5u a_inode 0,16 0 2087 [eventpoll:4,8,9]clash-ver 738 root 6u unix 0x00000000cb59cf7b 0t0 2387 type=STREAM (CONNECTED)clash-ver 738 root 7u unix 0x00000000093de046 0t0 2388 type=STREAM (CONNECTED)clash-ver 738 root 8u unix 0x00000000cb59cf7b 0t0 2387 type=STREAM (CONNECTED)clash-ver 738 root 9u IPv4 5515 0t0 TCP localhost:33211 (LISTEN) 检查服务状态 看看装了哪些服务 ❯ systemctl list-units|grep clash clash-verge-service.service 使用 systemctl status clash-verge-service.service 查看服务状态和文件位置，打开后如下 123456789101112[Unit]Description=Clash Verge Service helps to launch Clash Core.After=network-online.target nftables.service iptables.service[Service]Type=simpleExecStart=/usr/bin/clash-verge-serviceRestart=alwaysRestartSec=5[Install]WantedBy=multi-user.target Systemd serive 定义中，After=network-online.target nftables.service iptables.service 表明至少一个服务完成启动后才会启动 clash-verge-service。 我的系统使用 firewalld 作为防火墙,它会作为上层服务自动启用 nftables.service 和 iptables.service 作为底层服务，所以 nftables.service iptables.service 两个服务不会启动，因此只需要等待 network-online.target 启动完成即可。 测试 network-online.target 执行 systemctl start network-online.target，发现会卡死将近 2 min。使用 systemd-analyze critical-chain network-online.target 检查依赖和耗时，发现实际执行(CPU 时间)正常，但是启动前经过了长时间等待。 接下来查了下 network-online.target 的依赖和被依赖，没什么问题 1234567891011121314151617181920212223242526272829303132❯ systemctl list-dependencies network-online.target --afternetwork-online.target○ ├─NetworkManager-wait-online.service● └─network.target● ├─dhcpcd.service● ├─NetworkManager.service● ├─systemd-networkd.service● ├─wpa_supplicant.service● └─network-pre.target● ├─firewalld.service○ ├─ip6tables.service○ ├─iptables.service○ ├─nftables.service● └─systemd-network-generator.service❯ systemctl list-dependencies network-online.target --beforenetwork-online.target○ ├─archlinux-keyring-wkd-sync.service● ├─clash-verge-service.service○ ├─docker.service○ └─shutdown.target○ ├─systemd-halt.service○ ├─systemd-kexec.service○ ├─systemd-poweroff.service○ ├─systemd-reboot.service○ ├─systemd-soft-reboot.service○ └─final.target○ ├─systemd-halt.service○ ├─systemd-kexec.service○ ├─systemd-poweroff.service○ ├─systemd-reboot.service○ └─systemd-soft-reboot.service 同样，执行任何依赖于 network-online.target 的服务都会卡死将近 2 min（我就说我 docker.service 为什么启动慢） 参考 systemd.io，可以知道在使用 systemd 的系统中，network-online.target 一般会在网络连接成功后启动,用于确保服务在网络连接成功后启动来。如需要进行远程磁盘挂载、远程数据库连接等操作，可以将服务依赖于 network-online.target。 network-online.target 主要通过 NetworkManager-wait-online.service 或 systemd-networkd-wait-online.service 来启动。我使用的是 NetworkManager，所以应该是 NetworkManager-wait-online.service。 在 “To verify that the right service is enabled (usually only one should be):” 章节中提到了可以使用如下命令验证 service 正常配置： $ systemctl is-enabled NetworkManager-wait-online.service systemd-networkd-wait-online.servicedisabledenabled 经排查发现同时启用了 NetworkManager-wait-online.service 和 systemd-networkd-wait-online.service，导致了问题。禁用 systemd-networkd-wait-online.service 后，network-online.target 启动正常。","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"},{"name":"Systemd","slug":"Systemd","permalink":"http://blog.vollate.top/tags/Systemd/"}]},{"title":"CMake 从入门到能用就行","slug":"cmake-introduction","date":"2024-10-12T17:49:55.000Z","updated":"2024-10-13T10:35:01.000Z","comments":true,"path":"2024/10/12/cmake-introduction/","permalink":"http://blog.vollate.top/2024/10/12/cmake-introduction/","excerpt":"","text":"构建系统发展历史 手工编译 (1950s - 1960s): 编程语言刚刚诞生，程序员需要手工编译程序，将源代码转换为机器码。 批处理脚本 (1960s - 1970s)： 使用批处理脚本或 shell 脚本自动化编译命令，减少了手工输入。 Make 系统 (1970s)： Make 引入了增量编译的概念，只重新编译修改过的文件，大幅提升效率。 配置和生成工具 (1980s - 1990s)： Autotools 等工具通过自动生成跨平台的构建脚本，支持多平台开发，避免了手写 Makefile 的情况。 现代构建系统 (2000s - 2010s)： CMake 和 Meson 等工具采用声明式语法，简化了复杂项目的构建过程。 专用构建系统和构建工具链 (2010s - Present)：Ninja、Gradle、Bazel、Buck 等专注于加速大型项目的构建，提供高度的自定义功能。 云原生和分布式构建 (2010s - Now)： 支持云原生和分布式开发场景的构建系统，集成了容器化和 CI/CD 工具。 增量编译是指每次只编译修改过的编译单元，避免了无效编译。 例如，在 C/C++ 中，每个源文件对应一个编译单元，只有修改过的源文件才需要重新编译。同时由于预处理的原因，头文件的变更会递归影响到所有直接或间接引用该头文件的源文件。 GNU Make Make 是一个构建工具，通过 Makefile 文件定义项目的构建规则。Makefile 文件包含了一系列规则，每个规则由一个目标、依赖和命令组成。 1234567891011121314151617181920# VariableCC = clangCFLAGS = -Wall -Wextra -Werror# Targetall: programfoo.o: foo.c $(CC) $(CFLAGS) -c foo.c -o $@# $@ refers to the target# $&lt; refers to the first dependency# $^ refers to all dependenciesmain.o: main.c $(CC) $(CFLAGS) -c main.c -o $@program: main.o foo.o $(CC) $(CFLAGS) main.o foo.o -o programinclude subdir/Makefile make 是一个过程化的构建工具，需要手动书写构建命令，灵活度高但可维护性差。 CMake CMake 作为元构建系统，可以生成 Make、Ninja、Visual Studio 等构建系统所需的配置文件，方便的实现项目的跨平台。CMake 的配置文件是 CMakeLists.txt，通过编写 CMakeLists.txt 文件，可以定义项目的构建规则。 Version cmake 不同版本之间的命令可能有所不同，新版可能会添加新的命令，并且会废弃一些旧的命令（但大部分情况仍然可用）, 所以在编写 CMakeLists.txt 文件时，需要限定 CMake 的最低版本。 cmake_minimum_required(VERSION 3.16) # minimum cmake version# This is a line comment in cmake#[[ This is a block comment in cmake ]] Project Project 命令用于定义项目的名称和支持的语言。对于支持的语言，可以使用 C、CXX、CUDA、Fortran、ASM 等。默认情况下，CMake 会自动检测项目中的源文件，并根据文件后缀名推断语言类型。 Project 支持设置项目的版本号，可以通过 VERSION 选项指定项目的版本号。 project(hello_world) # project nameproject(hello_wrold VERSION 5.14 LANGUAGES CXX CUDA) # project name with languages Variable CMake 中的变量分为如下几种：普通变量，缓存变量，环境变量。 普通变量仅在本次运行cmake期间有效；缓存变量会被存储到生成项目目录的 CMakeCache.txt 文件中，用途主要有以下几点： 避免用户再次运行 cmake 重新设置变量 存储某些运行时信息，对用户不可见。如系统库的路径、编译器的路径等。 环境变量取决于运行 cmake 的环境 123456set(SRC_FILES main.cpp lib.cpp) # set Variableset(CMAKE_CXX_STANDARD 17) # set Variableset(CMAKE_CXX_STANDARD_REQUIRED ON cache) # set Cache Variablemessage(STATUS &quot;CMAKE_CXX_STANDARD: $&#123;CMAKE_CXX_STANDARD&#125;&quot;) # print messagemessage(WARNING &quot;$ENV&#123;USER&#125;&quot;) # print warning messagemessage(ERROR &quot;Error message&quot;) # print error message CMAKE 中，所有变量都是字符串，访问不存在的变量会返回空（不是空字符串），如果无法正常处理会产生问题。因此常用的方法是使用 if 判断变量是否存在。 if(DEFINED CMAKE_CXX_STANDARD) message(STATUS &quot;CMAKE_CXX_STANDARD: $&#123;CMAKE_CXX_STANDARD&#125;&quot;)else() message(WARNING &quot;CMAKE_CXX_STANDARD is not defined&quot;)endif() 在比较时，则可以直接加上引号，这样即使变量不存在也不会报错。 if(&quot;$&#123;CMAKE_CXX_STANDARD&#125;&quot; STREQUAL &quot;17&quot;) message(STATUS &quot;CMAKE_CXX_STANDARD is 17&quot;)else() message(WARNING &quot;CMAKE_CXX_STANDARD is not 17&quot;)endif() Control Flow 同大部分编程语言一样，CMake 也支持条件判断和循环控制。 if if 语句支持 AND、OR、NOT 逻辑运算符，可以使用 PARENT_SCOPE 选项将变量传递到父作用域。 1234567if(CMAKE_CXX_STANDARD EQUAL 17 OR ENABLE_CXX17) message(STATUS &quot;CMAKE_CXX_STANDARD is 17&quot;)elseif(CMAKE_CXX_STANDARD EQUAL 14 AND CMAKE_CXX_STANDARD_REQUIRED) message(STATUS &quot;CMAKE_CXX_STANDARD is 14&quot;)else() message(WARNING &quot;CMAKE_CXX_STANDARD is not 17 or 14&quot;) endif() 任何空字符串、0、FALSE、NOTFOUND、OFF、NO、N、IGNORE、无定义的变量都会被视为假，其他值都会被视为真。 loop CMake 支持 FOREACH、WHILE、WHILE、UNTIL 循环，其中 FOREACH 循环最为常用。 set(SRC_FILES main.cpp lib.cpp a.cpp b.cpp)foreach(file $&#123;SRC_FILES&#125;) message(STATUS &quot;Source file: $&#123;file&#125;&quot;)endforeach() Subdir CMake 支持子目录，可以通过 add_subdirectory 命令添加子目录，子目录中的 CMakeLists.txt 文件会被执行。 eg：假设项目目录结构如下 123456.├── 1│ └── CMakeLists.txt├── 2│ └── CMakeLists.txt└── CMakeLists.txt 根目录的 CMakeLists.txt 文件如下 12345678project(foo)set(useless &quot;root&quot;)message(STATUS &quot;Root: $&#123;useless&#125;&quot;)add_subdirectory(1)message(STATUS &quot;Root: $&#123;useless&#125;&quot;)add_subdirectory(2)message(STATUS &quot;Root: $&#123;useless&#125;&quot;)message(STATUS &quot;Root: $&#123;useless2&#125;&quot;) 1/CMakeLists.txt 文件如下 message(STATUS &quot;Dir1: $&#123;useless&#125;&quot;)set(useless &quot;dir1&quot;)message(STATUS &quot;Dir1: $&#123;useless&#125;&quot;) 2/CMakeLists.txt 文件如下 set(useless &quot;dir2&quot; PARENT_SCOPE)set(useless2 &quot;dir2&quot;)message(STATUS &quot;Dir2: $&#123;useless2&#125;&quot;) 运行cmake -Bbuild 输出如下 123456789// something-- Root: root-- Dir1: root-- Dir1: dir1-- Root: root-- Dir2: dir2-- Root: dir2-- Root:// something 可以看到，子目录中的变量不会影响到父目录，但是可以通过 PARENT_SCOPE 选项将变量传递到父目录。子目录调用完成后，返回到父目录，继续执行。 CMake 支持 include 命令，可以包含其他 CMakeLists.txt 文件。include 命令会将被包含的文件的内容直接插入到当前文件中，因此被包含的文件中定义的变量会影响到包含的文件。和 C/CPP的预处理#include 作用相同。 Executable/Lib CMake 中支持三种类型的构建目标：可执行文件（add_executable）、静态库（add_library STATIC）、动态库（add_library SHARED）。 add_executable(hello_world main.cpp) # add executable targetadd_library(hello STATIC lib.cpp) # add static library targetadd_library(hello SHARED lib.cpp) # add shared library target include_directories include_directories 命令用于添加头文件搜索路径，可以添加多个路径。使用 BEFORE 选项可以将路径添加到已有路径的前面，放置被其他路径覆盖。 include_directories(include/foo) # add include pathinclude_directories(BEFORE include/bar) # add include path before target_xxx target_xxx 系列命令用于设置目标的属性，如编译选项、链接选项、依赖等。分为三种属性：PRIVATE, PUBLIC, INTERFACE。 PRIVATE 属性只对当前目标有效, 不会传递给依赖目标 PUBLIC 属性对当前目标和依赖目标都有效 INTERFACE 属性只对依赖目标有效,不会对当前目标有效 target_include_directories(hello PUBLIC include) # add include path for target hello and any target that depends on hellotarget_compile_definitions(hello PRIVATE DEBUG) # add compile definition for target hellotarget_link_libraries(hello INTERFACE foo) # link library foo to targets who depends on hello 常用的 target_xxx 命令有： target_include_directories 添加头文件搜索路径 target_compile_definitions 添加编译宏定义 target_compile_options 添加编译选项 target_link_libraries 添加链接库 find_package find_package 命令用于查找外部库，有如下几种模式： Module 模式：在指定的路径下查找 Find&lt;package&gt;.cmake 文件，这个文件包含了查找库的规则，如何设置库的头文件路径、库文件路径、链接库等。 Config 模式：在指定的路径下查找 &lt;package&gt;Config.cmake 或 &lt;lower-case-package&gt;-config.cmake 文件，这个文件包含了库的配置信息，如头文件路径、库文件路径、链接库等。 其他可选项 REQUIRED: 如果找不到库，CMake 会报错并停止构建。如果 find_package 成功，会定义一个 &lt;package&gt;_FOUND 变量，表示找到库。 OPTIONAL: 如果找不到库，CMake 会继续构建。 QUIET: 失败时不输出警告。 PATHS &amp; HINTS: 指定查找路径，其中 HINTS 优先级高于 PATHS。 &lt;package&gt;_ROOT 变量或环境变量如果设置，会优先使用。 具体查找顺序参考 CMake 官方文档 💩 123456789find_package(Boost) # find boost libraryif(Boost_FOUND) message(STATUS &quot;Boost found&quot;)else() message(FATAL_ERROR &quot;Boost not found&quot;)endif()find_package(OpenCV CONFIG REQUIRED) # find opencv libraryfind_package(OpenGL REQUIRED HINTS /usr/lib) # find opengl library ctest ctest 是 CMake 的测试工具，可以用于运行测试。可以通过 add_test 指令添加对应的测试。签名如下: add_test(NAME &lt;test_name&gt; COMMAND &lt;executable&gt; [arg1 [arg2 ...]]) enable_testing() # enable testingadd_executable(test test.cpp) # add test targetadd_test(NAME example-test COMMAND test config.yaml &gt; $&#123;CMAKE_BINARY_DIR&#125;/test.log) # add test 常用变量 CMAKE_SOURCE_DIR: 项目根目录 CMAKE_BINARY_DIR: 项目构建目录 CMAKE_CURRENT_SOURCE_DIR: 当前处理的 CMakeLists.txt 文件所在的目录 CMAKE_PREFIX_PATH: 查找库的路径 CMAKE_MODULE_PATH: 查找模块的路径 CMAKE_INCLUDE_PATH: 查找头文件的路径 CMAKE_LIBRARY_PATH: 查找库文件的路径 CMAKE_INSTALL_PREFIX: 安装目录 CMAKE_BUILD_TYPE: 构建类型，如 Debug、Release、RelWithDebInfo、MinSizeRel CMAKE_C_COMPILER: C 编译器 CMAKE_CXX_COMPILER: C++ 编译器 CMAKE_C_FLAGS: C 编译选项 CMAKE_CXX_FLAGS: C++ 编译选项 CMAKE_EXE_LINKER_FLAGS: 可执行文件链接选项 CMAKE_LINKER_FLAGS: 链接选项 CMake Cli 虽然 CMake 有提供 GUI 工具，但是大部分情况下还是使用命令行工具。CMake 的命令行工具是 cmake，可以通过 cmake --help 查看帮助信息。 常用命令行参数： cmake -B&lt;build-dir&gt;: 指定构建目录 cmake &lt;source-dir&gt;: 指定源代码目录 cmake --build &lt;build-dir&gt;: 构建项目 cmake -D&lt;variable&gt;=&lt;value&gt;: 设置变量 ctest -C &lt;build-dir&gt;: 在指定的构建目录下运行测试 拓展 让 CMake install 支持 find_package vcpkg precompiled headers 废话 由于 CMake 语法过于复杂，实际使用时应多去官网查找用法。网址贴到这里，不过官网的文档查找效率低下，个人一般都是找大型 cmake 项目直接抄 CMakeLists.txt （","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"http://blog.vollate.top/tags/CMake/"}]},{"title":"配置自己的邮件服务器","slug":"deploy-self-mail-server","date":"2024-09-26T04:57:57.000Z","updated":"2024-09-26T04:58:26.000Z","comments":true,"path":"2024/09/26/deploy-self-mail-server/","permalink":"http://blog.vollate.top/2024/09/26/deploy-self-mail-server/","excerpt":"","text":"最近有事需要收发邮件，但是不想用自己的私人邮箱。正好手上有个域名，就想着自己搭建一个邮件服务器闲得慌，这里记录一下搭建过程。 选用的邮件服务器是 docker-mailserver，可以方便的在容器内部署，配置也相对简便，更改 docker-compose.yml 文件即可。 准备工作 服务器 首先需要一台服务器，然后装好 docker 和 docker-compose，我使用的是 Debian 12，安装过程不再赘述。 域名解析 在你的 DNS 服务商处添加 MX 记录，指向你的服务器地址。我使用 Cloudflare 托管，添加的 MX 记录如下： 123456Type: MXName: @ // 代表根域名Content: mail.example.com // 你的邮件服务器地址，这里使用 mail.example.com 作为示例，你可以使用自己的二级域名Priority: 10 // 优先级，如果只有一个邮件服务器，可以随意设置Proxied: DNS onlyTTL: Auto 完成后用 dig 命令检查 MX 记录是否生效： dig MX example.com 配置 SSL 证书 docker-mailserver 默认使用 Let’s Encrypt 证书，所以需要配置好域名解析，确保能够访问到你的服务器。如果你没有在服务器上部署任何网址(80端口未占用) Let’s Encrypt 会自动验证域名，生成证书。 在服务器上，可以使用 certbot 工具生成证书，你可以查看这个网站来获得在你 WebServer 和发行版上的最佳实现。我的服务器使用的是 Nginx。 sudo apt install certbotsudo apt install sudo certbot certonly --standalone -d mail.example.com -d example.com 部署 docker-mailserver 首先创建一个目录，用于存放 docker-compose.yml 文件和其他配置文件。 mkdir mailservercd mailserver 然后将 docker-compose.yml 文件下载到当前目录。 wget https://raw.githubusercontent.com/docker-mailserver/docker-mailserver/master/docker-compose.yml 根据你的需求修改 docker-compose.yml 文件，我修改后的文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940version: &#x27;3.8&#x27;services: mailserver: image: docker.io/mailserver/docker-mailserver:latest hostname: mail.example.com domainname: example.com container_name: mailserver ports: - &quot;25:25&quot; - &quot;143:143&quot; - &quot;465:465&quot; - &quot;587:587&quot; - &quot;993:993&quot; volumes: - ./docker-data/dms/mail-data/:/var/mail/ - ./docker-data/dms/mail-state/:/var/mail-state/ - ./docker-data/dms/mail-logs/:/var/log/mail/ - ./docker-data/dms/config/:/tmp/docker-mailserver/ - /etc/localtime:/etc/localtime:ro - /etc/letsencrypt:/etc/letsencrypt environment: - ENABLE_SPAMASSASSIN=1 - ENABLE_FAIL2BAN=1 - ENABLE_OPENDKIM=1 - ENABLE_OPENDMARC=1 - POSTFIX_MESSAGE_SIZE_LIMIT=102400000 - DMS_DEBUG=0 - SSL_TYPE=letsencrypt - SSL_DOMAIN=example.com - LETSENCRYPT_EMAIL=admin@example.com - SSL_LTS=1 cap_add: - NET_ADMIN restart: unless-stoppedvolumes: maildata: mailstate: maillogs: 完成后，运行 docker-compose up -d 启动容器。第一次启动后，要在120秒内创建第一个用户，否则容器会自动关闭。 docker exec -it mailserver setup email add xxx@example.com password 开放端口 在服务器上开放以下端口： 25: SMTP 143: IMAP 465: SMTPS 587: Submission 993: IMAPS 我的服务器使用 iptables 防火墙，开放端口的命令如下： iptables -A INPUT -p tcp --dport 25 -j ACCEPTiptables -A INPUT -p tcp --dport 143 -j ACCEPTiptables -A INPUT -p tcp --dport 465 -j ACCEPTiptables -A INPUT -p tcp --dport 587 -j ACCEPTiptables -A INPUT -p tcp --dport 993 -j ACCEPT 要持久化这些规则，可以使用 netfilter-persistent 工具： apt install iptables-persistent 执行 sudo netfilter-persistent save 保存规则。 进阶配置 刚刚配好的邮件服务器给 gmail 发邮件时，会被标记为垃圾邮件，这是因为缺少 SPF、DKIM 和 DMARC 记录。我们需要配置这些记录。 SPF SPF 是一种用于防范伪造邮件的技术，通过在 DNS 中添加 SPF 记录，可以指定哪些 IP 地址可以发送邮件。由于我们的邮件服务器只有一台，所以可以直接指定服务器的 IP 地址。在 Cloudflare 中添加 TXT 记录： Type: TXTName: @Content: v=spf1 mx -allTTL: Auto 解释： v=spf1：SPF 版本 mx：允许 MX 记录指定的服务器发送邮件 -all：拒绝所有其他服务器发送邮件 DKIM DomainKeys Identified Mail (DKIM) 是一种用于验证邮件来源的技术，通过在 DNS 中添加 DKIM 记录，可以验证邮件的真实性。docker-mailserver 已经为我们内置并自动开启了 OpenDKIM，我们只需要生成 DKIM 密钥并提取公钥添加到 DNS 中。官方文档中有详细的步骤。 由于我们需要指定特定子域名，所以需要在依照文档中 You may need to specify mail domains explicitly 部分的步骤中添加 -d mail.example.com 参数，命令如下： docker exec -it mailserver /bin/bashsetup config dkim domain &#x27;mail.example.com&#x27;setup config dkim domain mail.example.com 然后，在刚刚打开的 shell 中查看公钥： cat /tmp/docker-mailserver/opendkim/keys/mail.example.com/mail.txt 将输出的内容添加到 DNS 中，具体参考这块： Type: TXTName: mail._domainkeyContent: v=DKIM1; k=rsa; p=xxxxxxTTL: Auto DMARC Domain-based Message Authentication, Reporting and Conformance (DMARC) 是一种用于验证邮件来源的技术，通过在 DNS 中添加 DMARC 记录，可以指定邮件的处理方式。docker-mailserver 已经为我们内置并自动开启了 OpenDMARC，我们只需要添加 DMARC 记录。在 Cloudflare 中添加 TXT 记录： Type: TXTName: _dmarcContent: v=DMARC1; p=none; rua=mailto:admin@example.comTTL: Auto 解释： v=DMARC1：DMARC 版本 p=none：指定邮件的处理方式，none 表示不做任何处理 rua=mailto:：指定报告的接收邮箱 ruf=mailto:：指定失败报告的接收邮箱 sp=none：指定子域名的处理方式 adkim=s：指定 DKIM 的验证方式 aspf=r：指定 SPF 的验证方式 pct=100：指定报告的百分比 rf=afrf：指定报告的格式 rDNS 反向 DNS (rDNS) 是一种用于验证 IP 地址的技术，通过在 DNS 中添加 PTR 记录，可以验证 IP 地址的真实性。这需要联系服务器提供商来配置。 验证邮件服务器正常工作 我们可以使用 dkimvalidator.com 来验证 DKIM 和 DMARC 记录是否生效，使用 www.mail-tester.com 来验证邮件是否被标记为垃圾邮件。","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Server","slug":"Server","permalink":"http://blog.vollate.top/tags/Server/"},{"name":"Emali","slug":"Emali","permalink":"http://blog.vollate.top/tags/Emali/"}]},{"title":"使用 pass 管理密码","slug":"pass-sync","date":"2024-08-10T11:48:05.000Z","updated":"2024-12-13T19:29:40.000Z","comments":true,"path":"2024/08/10/pass-sync/","permalink":"http://blog.vollate.top/2024/08/10/pass-sync/","excerpt":"","text":"zx2c4 pass 是一个 unix 下的密码管理工具，使用 gpg 加密密码，配合 git 可以方便的实现密码同步，来彻底摆脱 browser 和其他各式各样非自由密码管理工具。 下面介绍 pass 的配置，密码迁移，以及各个客户端的使用方法。 配置 安装 pass UNIX like 系统直接使用包管理器安装即可，我的系统是 Arch, 使用 pacman 安装: # 已有 gpg 和 git 的忽略这步sudo pacman -S gnupg git# pass 本体为 cli 工具，可以配合 qtpass 来使用sudo pacman -S pass qtpass 如果是windows，可以尝试以下几个平替: gopass: go 实现的 pass，支持较全 prs: rust 实现的 pass，但不支持 extension pass-winmenu: 可以实现 pass 的基本功能，但为 GUI 应用 passpy: python 实现的 pass，功能补全且年久失修 pass4win: 年久失修且已经 archiving ，不建议使用 初始化 pass 在使用 pass 之前，先生成 gpg 密钥对。已有 gpg 密钥对可以跳过这一步。 123456789101112gpg --full-generate-key # 然后根据提示输入对应信息和你要设置的密码gpg --list-secret-keys --keyid-format LONG # 列出密钥的 gpg-id, 大概的输出长这样:# /home/foo/.gnupg/pubring.kbx# ----------------------------------# sec ed25519/xxx 20xx-xx-xx [SC] [expires: 20xx-xx-xx]# &lt;gpg-id&gt;# uid [ unknown] vollate &lt;uint44t@gmail.com&gt;# ssb cv25519/xxxxxxxxxxxxxxxx 20xx-xx-xx [E] [expires: 20xx-xx-xx]pass init &lt;gpg-id&gt; # 使用 gpg-id 初始化 pass 经过初始化，会生成 ~/.password-store 目录。目录下会生成一个 .gpg-id 文件，存放了用来加密密码的 gpg key 的 id。 如果你想要导入或导出 gpg key,使用下面的命令 # exportgpg --export-secret-keys -a &lt;gpg-id&gt; &gt; private.key# importgpg --import private.key 注意，使用 --export-secret-keys 导出私钥，否则行为为导出公钥。 同步密码 使用 git 来同步密码，这里使用 github 作为远程仓库。推荐使用 ssh-key 进行认证，因为github很早就停止了使用密码认证。 首先创建你的 private repo，不用添加 gitignore 或 readme，然后初始化你的 .password-store 并 ref 到远程仓库。或者你可以跟我一样偷懒 clone 下来然后 把 .git 扔进 .password-store 里。 之后就可以使用git 来管理密码了。 从浏览器迁移 firefox,chrome,edge都支持导出密码为 csv 文件，首先导出密码到 csv 文件，然后安装 pass-import。 使用下面的命令导入密码: pass import &lt;csv-file&gt; 更多用法见 useage 导出完后记得清空浏览器保存的密码。如果开启了云同步，需要在 history 中删除密码后同步到云端。 Chome 直接历史记录清除密码后会自动同步 Edge 需要在历史记录中删除密码后手动强制同步 firefox 在 password manager 右上角可以直接删除所有密码。 客户端 下面推荐几个个人使用的客户端: qtpass: pass 的 qt 客户端，支持图形化操作和一定 extension passff: firefox 插件，可以在浏览器中使用 pass 来填充密码，基本可以做到完全替代浏览器自带的密码管理器(但是 windows 上支持稀烂 修好了，详情见下) Android-Password-Store: Android 客户端，支持加密解密和 git 同步，但是自动填充稀烂 passff on windows 首先安装 passff-host， 按照官网说明下载 .bat 文件，然后运行,命令行参数选择你要安装的浏览器，我这里是 firefox。执行完成后会下载几个文件，位置自己翻脚本里面，和你安装的浏览器有关（或者everything直接搜 passff.py，对应文件夹就是）。安装 gopass,推荐使用 scoop 安装。 然后对 passff.py 开头部分进行修改 12345678910####################################################################################################### Begin preferences section ###########################################################################################################COMMAND = &quot;gopass&quot; # Rename this to your target pass-like executableCOMMAND_ARGS = []COMMAND_ENV = &#123; &quot;TREE_CHARSET&quot;: &quot;ISO-8859-1&quot;, &quot;PATH&quot;: os.environ.get(&quot;PATH&quot;), # Fix stupid path&#125;CHARSET = &quot;UTF-8&quot; 然后就可以在 windows 上的浏览器中使用 pass 了。 扩展 pass 支持 extension，具体参考这个合集，找自己需要的用。","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Password","slug":"Password","permalink":"http://blog.vollate.top/tags/Password/"}]},{"title":"Google GN CheatSheet","slug":"google-gn","date":"2024-07-14T06:44:21.000Z","updated":"2024-07-14T14:37:05.000Z","comments":true,"path":"2024/07/14/google-gn/","permalink":"http://blog.vollate.top/2024/07/14/google-gn/","excerpt":"","text":"基础语法 目标(Target) executable：定义一个可执行目标 executable(&quot;my_app&quot;) &#123; sources = [ &quot;main.cc&quot; ]&#125; shared_library：定义一个共享库目标 shared_library(&quot;my_shared_lib&quot;) &#123; sources = [ &quot;shared_lib.cc&quot; ]&#125; static_library：定义一个静态库目标 static_library(&quot;my_static_lib&quot;) &#123; sources = [ &quot;static_lib.cc&quot; ]&#125; source_set：定义一组源文件，通常用于中间构建 source_set(&quot;my_sources&quot;) &#123; sources = [ &quot;file1.cc&quot;, &quot;file2.cc&quot; ]&#125; 变量 sources：定义要包含在目标中的源文件列表 sources = [ &quot;main.cc&quot;, &quot;util.cc&quot; ] deps：定义目标的依赖项列表 deps = [ &quot;//:my_static_lib&quot; ] public_deps：类似于 deps，但会将依赖项公开给依赖此目标的其他目标 public_deps = [ &quot;//:my_shared_lib&quot; ] 函数 import：导入其他 GN 文件中的内容，只能在文件的顶部使用，用于配置变量和默认值 import(&quot;//build/config.gni&quot;) set_defaults：设置默认值，通常用于设置全局配置 set_defaults(&quot;executable&quot;) &#123; output_name = &quot;default_executable&quot;&#125; template：定义模板，便于复用构建规则(就是模板函数) 12345678910111213# definitiontemplate(&quot;foo&quot;) &#123; assert(defined(invoker.var1), &quot;var1 must be defined&quot;) print(invoker.var1) print(invoker.var2) # something&#125;# useagefoo(&quot;useless&quot;)&#123; var1 = &quot;foo&quot; var2 = &quot;bar&quot;&#125; 配置 config：定义一组编译或链接选项，可以在多个目标中复用 config(&quot;default_cflags&quot;) &#123; cflags = [ &quot;-Wall&quot;, &quot;-Werror&quot; ]&#125; 工具链 toolchain：定义一个工具链，用于指定编译和链接的工具及其选项 1234567891011toolchain(&quot;my_toolchain&quot;) &#123; tool(&quot;cc&quot;) &#123; command = &quot;gcc&quot; &#125; tool(&quot;cxx&quot;) &#123; command = &quot;g++&quot; &#125; tool(&quot;link&quot;) &#123; command = &quot;g++&quot; &#125;&#125; 过滤器(Filter) sources_assignment_filter：用于过滤 sources 列表中的文件 sources_assignment_filter = [ &quot;*.cc&quot;, &quot;*.h&quot; ] 分组 group：定义一个构建目标的分组 group(&quot;all&quot;) &#123; deps = [ &quot;:target1&quot;, &quot;:target2&quot; ]&#125; 外部脚本执行 exec_script：运行外部脚本，并将结果导入 GN 配置中 result = exec_script(&quot;find_sources.py&quot;, [], &quot;string_list&quot;)sources = result 控制流(control flow) if：条件语句，用于在 GN 文件中进行条件构建 1234567if (is_win) &#123; # win config&#125; else if (is_linux)&#123; # linux config&#125; else &#123; # other config&#125; foreach:编译列表 12345678var_list=[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]foreach(var, var_list) &#123; rubbish += var&#125; 作用域 set_defaults：设置默认值，通常用于设置全局配置 set_defaults(&quot;executable&quot;) &#123; output_name = &quot;default_executable&quot;&#125; scope：定义一个作用域，可以在 GN 文件中组织和管理变量和目标 scope(&quot;my_scope&quot;) &#123; sources = [ &quot;file1.cc&quot;, &quot;file2.cc&quot; ]&#125; 生成过程 和 CMake 类似，GN从根目录的 BUILD.gn 开始解析，通过 dependence 确定依赖子目录，然后在各个依赖的子目录中寻找 BUILD.gn 来构建依赖。解析文件的部分依赖脚本语言而不是 CMake 那样可以直接调用内置函数，有更高的灵活性，但是也更复杂。 常用命令/参数 gn gen out/Default --args='...': 在 out/Default 目录生成 ninja 构建文件 gn desc out/Default //some_path:target --$&#123;additional&#125;: 显示当前生成项目目录中某个 target 的详细信息 --tree: 显示生成 target 过程所有依赖调用顺序和参数 --blame: 显示生成 target 过程的编译参数中每个参数的来源 gn check out/Default: 检查当前项目的配置是否正确 gn format: 格式化所有 BUILD.gn 文件 gn gen --ide=$&#123;x&#125; out/Default 生成 IDE 项目文件 --ide=json 生成 JSON 格式的 IDE 项目文件,用于 clangd 等 --ide=vs 生成 Visual Studio 项目文件(只支持x64 win32 两种target plateform) --ide=xcode 生成 Xcode 项目文件","categories":[],"tags":[]},{"title":"LLDB 在 Docker 中功能异常","slug":"docker-lldb-error","date":"2024-06-26T16:36:35.000Z","updated":"2024-07-01T15:22:47.000Z","comments":true,"path":"2024/06/26/docker-lldb-error/","permalink":"http://blog.vollate.top/2024/06/26/docker-lldb-error/","excerpt":"","text":"记(寄)录 写 15445 的时候发现 clang-14 以上编译 fmt 会报错（arch 包太新了导致的），因此在 debian12 的 docker 中挂载 host 文件夹开发。用 lldb debug 时在出现 exception 或 signal后 lldb 会报错 A packet returned an error 8 并退出进程，导致无法 backtrace，但是 gdb 没事。 原因是因为 lldb debug 用的 syscall ptrace 在 docker 中被限制了，解决方法是在 docker run 时加上 --cap-add=SYS_PTRACE --security-opt seccomp=unconfined 参数。 Problem on stack overflow Docker 小知识 Linux capabilities: Docker 关于 Linux capabilities 的章节。这个是用来限制容器权限的，可以看到默认情况下 &quot;SYS_PTRACE Trace arbitrary processes using ptrace(2).&quot;是被禁用的，然后 lldb 就寄了（ Secure computing mode(Seccomp): 这是 Linux 内核的一个 feature,用于控制计算时的行为安全。Docker 默认的 profile 禁用了大约 44 个 syscall, ptrace 位列其中。通过 --security-opt seccomp=unconfined 来关闭这个 profile（图省事的不安全做法），正确的是改默认 profile 来自定义一个profile。然而我懒，就这样了。 ptrace 怎么不安全了 Docker 官方文档: Blocked in Linux kernel versions before 4.8 to avoid seccomp bypass. Tracing/profiling arbitrary processes is already blocked by dropping CAP_SYS_PTRACE, because it could leak a lot of information on the host. 上 NVD 搜了一圈，好多文档都写的禁止使用 ptrace, debugger 和 strace（used to trace syscal)，但是没说为啥。cgroup 和 namespace 不是已经隔离了吗，等哪天有空查到再研究下。 为什么 GDB 没事 TODO: 找了半天资料没找到，gdb internals 偏偏这一章是咕咕的，先洗洗睡了。","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.vollate.top/tags/Docker/"},{"name":"LLDB","slug":"LLDB","permalink":"http://blog.vollate.top/tags/LLDB/"}]},{"title":"gRPC & Protobuf 学习","slug":"protobuf-and-grpc","date":"2024-05-10T10:42:59.000Z","updated":"2024-06-14T15:23:41.000Z","comments":true,"path":"2024/05/10/protobuf-and-grpc/","permalink":"http://blog.vollate.top/2024/05/10/protobuf-and-grpc/","excerpt":"","text":"阅读须知 本文仅供学习参考，笔者的 protobuf 版本为 3.21.12.0，不保证其他版本的兼容性。 proto file .proto 格式文件可以被 protobuf(protocol buffer) 解析，用于定义服务和消息格式的语言。通过 protobuf 的 protoc 可以生成符合同一通讯协议的对应的代码框架，以此实现跨语言 rpc 通讯。 废话不多说，直接上例子 123456789101112131415161718192021222324252627282930313233343536373839404142syntax = &quot;proto3&quot;;// proto file versionpackage package_name;// define the serviceservice ChatService &#123; rpc PublishRoom(PublishRoomRequest) returns (PublishRoomReply); rpc GetRoomPeers(GetRoomPeersRequest) returns (GetRoomPeersReply);&#125;// define the status code(enum)enum StatusCode&#123; OK = 0; ERROR = 1;&#125;// define the request and reply messagemessage PublishRoomRequest &#123; string name = 1; string password = 2; oneof contact &#123;// like union in c/c++ string email = 3; string phone = 4; int64 id = 5; &#125;&#125;message PublishRoomReply &#123; bool success = 1; string message = 2;&#125;message GetRoomPeersRequest&#123; string name = 1; string password = 2; string id = 3;&#125;message GetRoomPeersReply&#123; bool success = 1; repeated string peers = 2; string message = 3;&#125; 好了，现在我们大概知道了如何编写一个 .proto 文件，接下来我们详细讲解细节 语法 首先附上官方文档 proto file 的语法分为两个版本，分别是 proto2 和 proto3，两个版语法本非常相似，但proto3 取消了 require/optional field，因此不建议给自己找事跨版本通讯。本文仅介绍 proto3 的语法。 在 .proto 文件的开头，我们需要声明使用的版本 syntax = &quot;proto$&#123;x&#125;&quot;;，$&#123;x&#125; 为版本号，一定要在开头声明，否则默认会使用 proto2 的语法。 接下来我们需要声明包名 package package_name;，包名用于区分不同的服务，避免命名冲突，实际编码中会转换成各个语言的包名或名称空间，如 C++ 会转换成 namespace package_name;， Rust 会转换成 mod package_name; service 用于定义服务，服务中包含多个 rpc 方法，rpc 方法包含请求和响应消息，具体会在后面讲解 之后是各类复合类型定义，如 enum、message 等，该模块和 service 定义没有顺序要求，只要 service 中使用的复合类型在本文件中定义即可 Scalar Value Types gRPC 中共用如下几种基础类型，在编译时会转换成对应语言的基础类型: 变长编码（Varint）： int32（有符号整数） int64（有符号整数） uint32（无符号整数） uint64（无符号整数） sint32（有符号整数，使用 ZigZag 编码） sint64（有符号整数，使用 ZigZag 编码） bool（布尔值，存储为 0 或 1） enum（枚举，通常作为 Varint 编码的整数） 固定长度编码： fixed32（32 位有符号整数，固定 4 字节） fixed64（64 位有符号整数，固定 8 字节） sfixed32（32 位有符号整数，固定 4 字节） sfixed64（64 位有符号整数，固定 8 字节） float（32 位浮点数，固定 4 字节） double（64 位浮点数，固定 8 字节） 长度前缀编码： string（字符串） bytes（二进制数据） message（嵌套消息） 这种多种编码方式允许 Protocol Buffers 以高效和紧凑的方式进行序列化。 各语言具体转换，点我展开 .proto TypeNotesC++ TypeJava/Kotlin Type[1]Python Type[3]Go TypeRuby TypeC# TypePHP TypeDart Typedoubledoubledoublefloatfloat64Floatdoublefloatdoublefloatfloatfloatfloatfloat32Floatfloatfloatdoubleint32Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.int32intintint32Fixnum or Bignum (as required)intintegerintint64Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.int64longint/long[4]int64Bignumlonginteger/string[6]Int64uint32Uses variable-length encoding.uint32int[2]int/long[4]uint32Fixnum or Bignum (as required)uintintegerintuint64Uses variable-length encoding.uint64long[2]int/long[4]uint64Bignumulonginteger/string[6]Int64sint32Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.int32intintint32Fixnum or Bignum (as required)intintegerintsint64Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.int64longint/long[4]int64Bignumlonginteger/string[6]Int64fixed32Always four bytes. More efficient than uint32 if values are often greater than 228.uint32int[2]int/long[4]uint32Fixnum or Bignum (as required)uintintegerintfixed64Always eight bytes. More efficient than uint64 if values are often greater than 256.uint64long[2]int/long[4]uint64Bignumulonginteger/string[6]Int64sfixed32Always four bytes.int32intintint32Fixnum or Bignum (as required)intintegerintsfixed64Always eight bytes.int64longint/long[4]int64Bignumlonginteger/string[6]Int64boolboolbooleanboolboolTrueClass/FalseClassboolbooleanboolstringA string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.stringStringstr/unicode[5]stringString (UTF-8)stringstringStringbytesMay contain any arbitrary sequence of bytes no longer than 232.stringByteStringstr (Python 2)bytes (Python 3)[]byteString (ASCII-8BIT)ByteStringstringList 这是官网的表格照抄结果，请以官方文档为准以避免任何时效性问题。官方文档链接 Enumerations Union(Variant) 123456789message PublishRoomRequest &#123; string name = 1; string password = 2; oneof contact &#123;// like union in c/c++ string email = 3; string phone = 4; int64 id = 5; &#125;&#125; Message 就是 Struct, 用于定义复杂的数据结构，可以嵌套定义，可以包含 enum、message、oneof 等 可以用 repeated 关键字定义数组 123456789101112131415161718message Person &#123; string name = 1; int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2; &#125; repeated PhoneNumber phones = 4;&#125; Service 定义 service ChatService &#123; rpc PublishRoom(PublishRoomRequest) returns (PublishRoomReply); rpc GetRoomPeers(GetRoomPeersRequest) returns (stream GetRoomPeersReply); rpc GetRoomsPeers(stream GetRoomPeersRequest) returns (stream GetRoomPeersReply);&#125; stream use to specify a stream message, which means the server or client can send or receive multiple messages in one rpc call. grpc 一些教程 官网找自己要用的语言去看 找的某个 blog 有趣的东西 语法说实话没啥看的，用的时候再查，但是编码挺好玩的。官方介绍 可变长度编码 将原数按小端序编码，然后分为 7 bits 一组，每 byte 的 MSB（最高位）表示是否还有后续(0表示无，1表示有)。由于按小端序而不是传统的大端序（网络字节序），可以节省数字较小时高位的存储空间。当然对于大数需要最多10 bytes来传输，因此在已知数据都较大时应直接使用定长编码。 ZigZag 编码 为了解决负数而生。因为负数的标准表示方式是 MSB 设 1 的 2 补码，会导致大负数的可变长度编码远远长于同绝对值的正数。如果是期望为 0 的高斯分布，用上面的变长编码会产生很大的消耗。ZigZag 编码将负数映射到正数，使得绝对值较小的负数的编码长度接近于正数。 编码: n &lt;&lt; 1 ^ n &gt;&gt; len, 其中 len 为 n 的位数 解码: (n &gt;&gt; 1) ^ -(n &amp; 1) 本质: 只用正数表示绝对值大小，符号位从 MSB 换为 LSB, 这样让上面的变长编码关于绝对值大小的优势得以保留。","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://blog.vollate.top/tags/Notes/"},{"name":"RPC","slug":"RPC","permalink":"http://blog.vollate.top/tags/RPC/"}]},{"title":"Arch Linux 下 Firefox 无法正确显示 emoji","slug":"missing-emoji","date":"2024-02-20T16:11:59.000Z","updated":"2024-12-02T12:46:31.000Z","comments":true,"path":"2024/02/20/missing-emoji/","permalink":"http://blog.vollate.top/2024/02/20/missing-emoji/","excerpt":"","text":"问题描述 firefox 无法显示任何 emoji，但 chrome，edge 均显示正常 折腾过程 首先怀疑是 firefox 什么地方配置炸了。搜了几篇提问，解决方案都无效，包括 Arch wiki 上的这个。 然后我开了下自己另一台电脑上的 Arch 发现显示正常，于是推断可能是缺字体。具体是什么不清楚，但是包名中大概带 “emoji”。搜了半天没找到个能用的解决方案，noto-font-emoji 装了也没用。最后不抱希望搜了下package，原以为会出现一堆带 emoji 的，结果就十几个。看了看，觉得缺少 “unicode-emoji” 的可能性最高，装了，好了。 然后发现 vim 中的 warning 字体突然变成 unicode 里面那个黄色 warning（丑），于是又把包卸了。重启后发现 firefox 中 emoji 正常显示，大概是本地哪个配置文件炸了一开始才显示不了。 总结 人生 -1h 强迫症满足++ 折腾 Linux 经验++","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"},{"name":"KDE Plasma","slug":"KDE-Plasma","permalink":"http://blog.vollate.top/tags/KDE-Plasma/"}]},{"title":"Linux 下系统代理配置","slug":"linux-desktop-system-proxy","date":"2024-01-09T15:57:33.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2024/01/09/linux-desktop-system-proxy/","permalink":"http://blog.vollate.top/2024/01/09/linux-desktop-system-proxy/","excerpt":"","text":"配置 firefox 系统代理时出现了一些问题，然后查了下 Linux 桌面系统代理的原理，记录一下 系统信息: 12345678OS: Arch Linux x86_64 Kernel: 6.6.10-arch1-1 Packages: 1369 (pacman) Shell: zsh 5.9 DE: Plasma 5.27.10 WM: KWin Theme: [Plasma], Canta-dark [GTK2/3] Icons: Tela-circle-manjaro-dark [Plasma], Tela-circle-manjaro-dark [GTK2/3] 使用 clash-verge 进行代理，然后 system-proxy 设置为 manual 后 edge 和 chrome 能正常识别。但是 firefox 死活不行，上网查了不支持代理的问题是11年前的。 无奈开始怀疑是 firefox 不支持 KDE 桌面环境的系统代理设置。 KDE 系统代理配置 如上图，配置好后，系统代理的信息可以在 ~/.config/kioslaverc 中找到 GNOME 系统代理配置 GNOME 桌面同样可以通过 GUI 配置系统代理，具体不展示了因为没 GNOME 桌面(全用Arch导致的。GNOME 下桌面应用可以通过 gsettings 来获取对应的 key 值，如 gsettings get org.gnome.system.proxy mode 可以获取现在的系统代理模式。 解决问题 发现 clash-verge 内置的系统代理配置的是 gsettings 的选项，而且 firefox 只认 GNOME 的系统代理配置(Mozilla 快把 firefox 玩死了)。因此之前一直没有成功。Ubuntu 用户太多导致软件适配倾向于 GNOME 桌面，但是真的好丑啊 GNOME。 小贴士：一般桌面 app 不吃 env variable 这一套","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"http://blog.vollate.top/tags/Proxy/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"}]},{"title":"VPS 测试脚本整理","slug":"vps-testscripts","date":"2023-12-13T07:44:50.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2023/12/13/vps-testscripts/","permalink":"http://blog.vollate.top/2023/12/13/vps-testscripts/","excerpt":"","text":"整理自知乎 基础测试(IO+网速) Bench wget -qO- bench.sh | bashcurl -Lso- bench.sh | bashwget -qO- 86.re/bench.sh | bashcurl -so- 86.re/bench.sh | bash SuperBench 会安装较多东西，测得也较全，并且网络测速注重回国速度 wget -qO- --no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superbench.sh | bashcurl -Lso- -no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superb Superseed 提供测试全国各地三大运营商速度 wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh &amp;&amp; chmod +x superspeed.sh &amp;&amp; ./superspeed.sh UnixBench 主要测试项目有：系统调用、读写、进程、图形化测试、2D、3D、管道、运算、C库等系统基准性能提供测试数据，发布页 wget --no-check-certificate https://github.com/teddysun/across/raw/master/unixbench.shchmod +x unixbench.sh./unixbench.sh Memory Test 123456789101112#CentOS / RHELyum install wget -yyum groupinstall &quot;Development Tools&quot; -ywget https://raw.githubusercontent.com/FunctionClub/Memtester/master/memtester.cppgcc -l stdc++ memtester.cpp./a.out#Ubuntu / Debianapt-get updateapt-get install wget build-essential -ywget https://raw.githubusercontent.com/FunctionClub/Memtester/master/memtester.cppgcc -l stdc++ memtester.cpp./a.out","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Server","slug":"Server","permalink":"http://blog.vollate.top/tags/Server/"}]},{"title":"编译之法","slug":"compile-knowledge","date":"2023-12-08T07:34:57.000Z","updated":"2024-10-13T10:35:01.000Z","comments":true,"path":"2023/12/08/compile-knowledge/","permalink":"http://blog.vollate.top/2023/12/08/compile-knowledge/","excerpt":"","text":"以 C/C++ 为例，简单介绍一下 Linux 下编译的相关知识。看完应该能掌握基础的编译能力，处理报错不再抓瞎。 麻麻再也不用担心我遇到问题只能瞎逛 stackoverflow 了 该逛还得逛 基础知识 编译型语言与解释型语言 编译型语言是将代码直接编译成机器可以直接执行的机器码，可以直接在目标机器上执行。代表是 Fortran, C, C++, RUST, Go 等。 解释型语言是通过解释器逐行解释每条命令来执行对应的操作，运行不需要编译，但是需要对应的解释器解释成对应架构的指令。代表是 Python, ECMAScript, PHP 等等。 也还有一些两者兼具的，如 JAVA，编译成字节码，然后由 JVM 解释执行。 汇编语言 汇编语言是最接近于机器码的语言，和目标机器的指令集架构紧密相关也称为低级语言。指令集是一种抽象，它将计算机的物理实现抽象成指令集规定的一系列操作，使得同一架构的不同型号计算机能运算同一个程序，且规定了程序如何操作硬件完成计算。汇编之所以成为最接近于机器码的语言，是在于它只需要进行简单的替换就能生成对应的机器码。 举个 MIPS32 架构汇编的例子： add $1,$2,$3 这条指令将2和3号寄存器的值相加存储到1号寄存器中，根据 MIPS32 的转换规则，生成的二进制机器码如下: opcode rs rt rd shamt func 000000 00010 00011 00001 00000 100000 操作码（opcode）：对于 add 操作，它的操作码是 000000。 源寄存器2（rs）：$2 对应的寄存器是 00010。 源寄存器3（rt）：$3 对应的寄存器是 00011。 目标寄存器（rd）：$1 对应的寄存器是 00001。 移位量（shamt）：对于 add 操作而言，不涉及移位，因此为 00000。 功能码（funct）：add 操作的功能码是 100000。 汇编语言经过简单的处理就可以直接转换为机器码，但是有许多坏处: 可读性差。以下是一个 clang 生成的简单的 hello world 程序的汇编代码 12345678910111213141516171819202122232425262728293031323334353637 .text .file &quot;test.c&quot; .globl main # -- Begin function main .p2align 4, 0x90 .type main,@functionmain: # @main .cfi_startproc# %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp movl $0, -4(%rbp) leaq .L.str(%rip), %rdi movb $0, %al callq printf@PLT xorl %eax, %eax addq $16, %rsp popq %rbp .cfi_def_cfa %rsp, 8 retq.Lfunc_end0: .size main, .Lfunc_end0-main .cfi_endproc # -- End function .type .L.str,@object # @.str .section .rodata.str1.1,&quot;aMS&quot;,@progbits,1.L.str: .asciz &quot;Hello, World!\\n&quot; .size .L.str, 15 .ident &quot;clang version 16.0.6&quot; .section &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits .addrsig .addrsig_sym printf 汇编中没有我们常用的控制流，需要手写判断跳转的操作 2. 可移植性差，只使用于特定架构的计算机。如果你想要你的汇编程序同时在 arm64 和 x86_64 上运行，你需要写两份代码。 3. 其他就不一一列举了…… 函数声明和定义 在编程中，我们用函数来表示一种特定的操作，它能够处理我们的输入并且产生对应的输出(副作用)。想深入了解可以看看λ演算，这里就不过多介绍了。函数能够简化我们的代码，对于需要在多处重复执行的操作，我们通过将他包装成函数来简化我们的代码。 函数的声明就是告诉编译器我们有这么一个叫xxx的函数，它的输入和输出都是什么类型。定义则是具体描述了函数如何处理输入最终得到输出。 在编程中，函数往往是声明和定义分开，来将逻辑和函数解耦。在 C/C++ 中，我们通常使用 #include 预处理命令来引用头文件，头文件中包含了函数声明。预处理器会直接将被 include 的文件内容复制到预处理后的文件对应位置中。 编译过程 编译器是一种计算机程序，它会将某种编程语言写成的源代码转换成另一种编程语言。主要用途是将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为目标机器能解读、运行的低阶机器语言的程序。将高级语言转化为低级语言的过程称为编译，反过来成为反编译。 一般编译的过程分为如下步骤: 预处理: 进行文本替换等其他操作，如 C/C++ 里 “#xxx” 预处理命令的展开以及宏的替换 编译：将源代码转换为对应架构的汇编代码，生成.s汇编文件 汇编：将上一步生成的汇编代码翻译成二进制机器码，生成.o object 文件 链接：将上一步生成的文件和所需要的静态/动态库链接为一个新的 object 文件 注意不是所有语言的编译都有上述的几个部分，如 JAVA 。 静态链接和动态链接 我们可以通过声明让在多个地方使用函数而只需提供一次定义，同理，多个文件可以共用同一个函数，只需要链接包含了函数定义的 library 即可，无需重复编译。链接方式有如下两种: 静态链接：将被链接的库的所有代码嵌入到新的可执行文件或目标文件中。 优点：生成的可执行文件不需要依赖外部库 缺点： 生成文件变大 如果被链接的库更新，需要重新编译 无法重复利用共享库 动态链接：在程序运行时或运行前的装载阶段将外部库代码加载到内存中的过程。可执行文件只包含对这些库的引用，不包含实际的库代码 优点： 可执行文件可以更小 多个可执行文件可以复用同一个 lib 如果更新不改变函数接口，则无需重新编译 缺点： 会依赖外部库，如 linux 的 glibc。如果版本不兼容，运行时会报错。 启动时会略微增加时间 动态链接库 .dll (Dynamic link library)是 Windows 下的的称呼，在 Unix/Linux 下称为 Shared Object .so，本文会统一叫动态链接库(叫顺口了)。 Linux 下，静态链接库一般以 .a 结尾 (archive) gcc/clang 使用 本章主要介绍在命令行中使用 gcc/clang 进行编译的的过程和注意事项，以下命令中的 clang 都可以换成 gcc。但是注意，不同编译器所支持的编译参数并不完全相同，因此项目中需要对不同的编译器进行不同参数的适配。 获取帮助 man clang，man 是 Linux 下的一个 reference 页面，安装的程序可以以一定格式提供 manual 供 man 命令调用。man 使用 vim 的键位，按 / 建开始搜索，n 建下一个，N 键上一个，按 q 键退出。你可以使用 man man 来查看 man 的 manual，如果你只想获得简单的帮助，请使用 clang --help 编译一个文件，生成可执行文件 test.c clang test.c -o test 注意，在 clang/gcc 默认使用 “main” 作为主函数的入点，如果你的文件中没有 main 函数，编译会报错，因为编译器没有找到主函数入口。这里我们使用 “-o” 指定输出文件名称，如果不指定，默认为 “a.out” 编译一个库 mBool.c 123456789# static libclang -c mBool.c -o mBool.o # 这里不写默认生成同名后缀为.o的对应文件ar r mBool.a mBool.o # for GNU toolchainllvm-ar r libmBool.a mBool.o # for llvm toolchain# ar 将所有(这里只有一个) .o 文件打包，并创建一个索引表以供查找。某些情况，会选择性对文件进行压缩# shared libclang -shared mBool.c -o libmBool.so -fPIC# 上述动态链接库的编译过程中使用了 `-fPIC` 这个参数，意味着生成 position independent code，这样我们的动态链接库就可以在任意地址被装载。 链接一个库 mBoolTest.c 这里我懒得写头文件了，直接前置声明了 123456789101112# link the static libclang -o mTest.out mBoolTest.c `pwd`/mBool.aclang -o mTest.out -static mBoolTest.c -L`pwd` -lmBool # if no shared lib, &quot;-static&quot; is uneeded# link the shared libclang -o mTest.out mBoolTest.c -L`pwd` -lmBool# ref:# -L$&#123;target_lib_path&#125;# -l$&#123;lib_name&#125; # compiler will try to find lib$&#123;lib_name&#125;.a/so# -l:$&#123;custom_lib_name&#125;# -static # use static link 对于静态链接库，我们直接将其作为输入即可链接，因为其本质上就是一个编译后生成的二进制文件 .o 对于动态链接库，编译器会有一些系统默认的动态库目录，它会进入目录下查找。显然我们当前的文件夹并不在此之列，因此为了让编译器进入我们当前的目录下查找链接库，我们使用 -L 来加入我们库所在的目录来让编译器查找。我们之前将编译出来的库命名为 “libmBool.*”，因此可以直接使用 -l 来链接我们的库。因为我们的目录下同时存在静态和动态链接库，因此编译器默认使用动态链接。我们可以使用 -static 来让编译器使用静态链接库。 使用 -rpath/-runpath 现在我们尝试运行我们刚刚链接完动态链接库的可执行文件，然后就报错了 ./mTest.out: error while loading shared libraries: libmBool.so: cannot open shared object file: No such file or directory 系统提示我们找不到动态链接库。因为我们没有存储动态链接库的位置，动态链接器(如 ld-linux.so)不知道去哪加载我们的动态链接库我们使用 -rpath 来存储动态链接库的目录信息。可以使用绝对路径或相对路径，一般使用相对路径，这样程序只要保持文件内的结构不变即可在各处执行。注意，这个参数是加给链接器的，clang 可以直接传递给链接器，但是 gcc 需要使用 -Wl 来传递给链接器。runpath 和 rpath 相比，更新，一些老旧的动态链接器可能不支持，但是提供了更多的灵活性，具体下面会讲到。 1234567891011121314# use relative pathclang -o mTest.out mBoolTest.c -L`pwd` -lmBool -rpath . # clang could ignore the -Wl for rpath, but gcc can&#x27;tclang -o mTest.out mBoolTest.c -L`pwd` -lmBool -Wl,-rpath . # also worksgcc -o mTest.out mBoolTest.c -L`pwd` -lmBool -Wl,-rpath .# use absolute pathclang -o mTest.out mBoolTest.c -L`pwd` -lmBool -rpath `pwd`clang -o mTest.out mBoolTest.c -L`pwd` -lmBool -Wl,-rpath `pwd`# use runpathclang -o mTest.out mBoolTest.c -L`pwd` -lmBool -Wl,--enable-new-dtags -Wl,-rpath . # gcc paremeter is the same# force use rpath(disable runpath)clang -o mTest.out mBoolTest.c -L`pwd` -lmBool -Wl,-rpath . -Wl,--disable-new-dtags 引用头文件 现在我们不偷懒了，引入一个头文件 head.h，创建一个 nMBoolTest.c，假设头文件存储在目录 /tmp 下，我们要让编译器知道我们头文件的位置，使用 -I 选项 clang -o nTest.out nMBoolTest.c -L`pwd` -lmBool -rpath `pwd` -I/tmp 使用环境变量 假设我们没有 make，cmake 这样的自动化构建工具，或者有一个复杂无比的 Makefile/CMakeLists.txt，无法轻易更改。我们需要让编译器知道我们自定义的 header 和 lib 的位置，这时候就需要我们的环境变量登场了。下面介绍一些常用的，更多的看对应编译器的文档，GCC C_INCLUDE_PATH：阅读理解（ C_PATH：same as above CPLUS_INCLUDE_PATH：阅读理解（ LIBRARY_PATH：告诉链接器库的位置，链接时会进入该目录搜索 LD_LIBRARY_PATH: 告诉动态链接器库的位置，运行时会进入该目录搜索 以上写法写法同 PATH，用 : 分隔每个路径 ld.so(动态链接器) 搜索顺序: 编译时设置的 rpath 路径 环境变量 LD_LIBRARY_PATH 编译时设置的 runpath: runpath 的搜索优先级低于 LD_LIBRARY_PATH，因此它可以允许用户设置 LD_LIBRARY_PATH 来覆盖 runpath 指定的库，提供更多的灵活性。而 rpath 则不行。当然，这也意味着有可能会无意间使用不同版本的库，造成一些问题。 缓存文件(如 /etc/ld.so.cache): 包含了当前环境中可用库的索引，可以使用 ldconfig 来更新 默认路径，如 “/lib”, “/usr/lib” 等等 常用编译选项: -g: generate debug info -O0, -O1, -O3, -Ofast: 设置编译器优化等级，等级越高优化越多。O0无优化，Ofast 启用O3的同时使用一些不符合 ISO 标准的优化 -v：输出执行的命令 -x：显示指定语言类型 -std=：指定语言标准 -Wall：启用几乎所有 warning -Werror: 将所有 warning 当作 error -Wno-deprecated：如果使用了编译器被弃用的功能，不要产生 warning -Wno-deprecated-declarations：不要对使用 C++ 中的 [[deprecated]] 修饰的对象产生 warning -mx32：生成32位x86代码 -stdlib=：指定使用的标准库 -E：只进行预处理 -S：生成汇编代码后停止 -c：编译或汇编对象文件，但不链接 more: read the manual 常见问题解决 报错了：学会看报错，报错是帮你解决问题的，看不懂把报错扔搜索引擎上多半能出来(注意不要复制过多本地环境的无效信息) 心态崩了：缓上个半天继续整 完","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"}],"tags":[{"name":"Compiler","slug":"Compiler","permalink":"http://blog.vollate.top/tags/Compiler/"}]},{"title":"浅记系统虚拟化","slug":"virtualization","date":"2023-11-17T11:24:06.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2023/11/17/virtualization/","permalink":"http://blog.vollate.top/2023/11/17/virtualization/","excerpt":"","text":"最近由于项目需要学习虚拟化的知识，于是在师兄的建议下读了 sjtu 出的新书《操作系统原理与实践》中的系统虚拟化的部分，随便记点笔记。 虚拟化发展历史: 1960s出现分时操作系统概念。同时期IBM进行了另一个方向也就是虚拟化的探索，并在1968年的system360上实现了第一个VMM(Virtual Machine Monitor) CP/CMS 1980s，开始出现纯软件实现的虚拟机监视器 1990s, 互联网兴起，web服务器逐渐性能过剩 1998年，VMware成立。 云计算兴起，虚拟化越发重要 优势: 充分利用服务器性能，搞超售 虚拟机管理更为便捷，可以快速部署销毁 可以热迁移 VMI (Virtual Machine Introspection 虚拟机自省)可以从外部检查虚拟机是否被入侵 系统虚拟化概述 组成部分 CPU 虚拟化（vCPU）：若虚拟化的指令集和物理架构指令集相同，除了部分特殊指令其他都可以直接执行，效率较高（KVM）；若架构不同，则需要全部转译执行。 内存虚拟化：引入虚拟物理地址，内存访问需要多经过一层虚拟物理地址到物理地址的映射操作。 I/O 虚拟化：VMM 提供虚拟驱动供虚拟机使用，并将操作转化为实际的物理设备访问或其他操作。 VMM 类型 半虚拟化: 运行在最高权限级别，相当于一个以OS作为进程的操作系统，如 Xen。 完全虚拟化：作为一个进程运行在 OS 上，复用宿主OS的线程调度和资源管理，如 QEMU。 Trap-Emulate（下陷-模拟） Trap：将系统级ISA拦截转由 VMM 进行模拟操作。如系统调用先转化为虚拟机内核态，然后由 VMM 拦截并完成对应调用的模拟。 Emulate：用软件模拟执行后的副作用 基础概念: CPU 上下文：指CPU在执行特定进程或任务时所需的信息集合。一般包括该CPU的所有寄存器（包括PC）的值和当前系统状态（内存信息，调度优先级等）。 中断向量表（Interrupt Vector Table）：存放中断处理函数。 中断处理过程：触发中断时，首先检查中断是否开启。若开启，CPU 接收中断信号并暂停当前程序处理。然后保存当前上下文以供恢复。然后确定中断类型并从中断向量表中查找对应处理函数的地址并跳转执行。执行结束后，恢复中断前的上下文。 用户态：用户态是普通应用程序运行的模式。该模式下，程序对硬件的访问受限，一般通过OS提供系统调用切换到内核态来执行对应函数进行访问。 内核态：OS 一般运行在该状态下。该状态下，OS 能够完全访问并操作硬件，访问所有内存。 Trap-Emulate 虚拟化实现 VMM 需提供数据结构，来存储原本存储在物理 CPU 上的所有进程上下文信息，以及对应的其它信息（如中断向量表,虚拟页表等）。 处理中断：对于硬件中断，将会触发 VMM 查看虚拟机是否开启对应中断。如开启，虚拟机保存上下文后下陷到 VMM，然后 VMM 检查中断向量表处理中断。 处理系统调用：同中断处理的模式，只是 VMM 需要隔离用户态和内核态的页表映射 处理线程切换：本质软件中断到内核态然后进行线程调度，切换进程上下文即可。 多 CPU 模拟：加个数据结构存进程上下文和 vCPU 的对应关系就行。vCPU 调度参考 OS 的进程调度，或者直接用线程 OS 进程来实现。 CPU虚拟化 特权指令：在用户态执行时会下陷进入特权级的指令 敏感指令：管理物理硬件资源或更改CPU状态的指令 eg： x86 修改 CR 寄存器的值 读写敏感内存 I/O 指令 可虚拟化和不可虚拟化架构 所有满足敏感指令都是特权指令的架构称为可虚拟化架构，反之则为不可虚拟化架构。 eg: AArch32 早期 x86 弥补不可虚拟化架构的方法 全虚拟化 适用于无需修改客户端源码的情况 解释执行：用纯软件模拟cpu执行指令过程。具体操作是对于每条指令调用对应的用于模拟的函数，整个过程不产生任何下陷。优点是可以模拟任何 ISA 类型的虚拟机。缺点显而易见，效率低下。 动态二进制编译：在解释执行的基础上将程序划分为只有一个入口和一个出口,中间无任何修改控制流指令的代码块(相当于创建了一个函数)。第一次执行该块时进行翻译并缓存，之后再执行时调用之前的缓存。翻译替换所有敏感指令，在块的末尾添加一条跳转指令来通知 VMM 执行完毕。 扫描-翻译：用于虚拟机架构和宿主相同的情况，在程序执行前扫描可能存在敏感指令的代码，翻译并缓存翻译后的代码以便下次复用。大多数情况敏感指令只存在于 OS kernal 中，可以只扫描内核代码。 半虚拟化 在允许修改虚拟机客户端代码的情况下可以使用 原理：通过 VMM 提供的类似系统调用的服务使得虚拟机内核不再需要下陷模拟，而是类似进程使用系统调用一样进行对应操作，效率更高。半虚拟化使得 VMM 获得查看客户端内存分布的能力，能够更合理的分配资源。 硬件虚拟化 通过 CPU 硬件支持来实现更高效的虚拟化。具体来说就是增加一个专为 VMM 运行的特权级，该特权级下 VMM 拥有和宿主 OS 相同的硬件访问权限，来节省下陷的开销。 拓展——KVM (kernal-based virtual machine) 技术: 通过将 VMM 作为内核模块加载使得 VMM 能够使用 宿主 OS 内核的功能，这样下陷时某些支持的架构可以消除 KVM 到 OS 内核特权级转换带来的开销。指令无需翻译，直接在硬件上执行，使得虚拟化效率接近直接运行。 内存虚拟化 目标：实现虚拟机之间，虚拟机和物理机之间的内存隔离 术语： GVA: Guest Virtual Address GPA: Guest Physical Address HPA: Host Physical Address 影子页表(Shadow Page Table) 复习进程页表的配置&amp;使用： 调用前 OS 为进程配置一个虚拟地址映射到物理地址的静态页表（相对地址） OS 将页表基地址写入对应寄存器以让 MMU 能找到页表 MMU 解析虚拟地址到物理地址 内存虚拟化中，VMM 需要根据存储的 GPA 到 HPA 的映射信息并生成一个 GVA 到 HPA 的影子页表。在虚拟机下陷时,将页表基地址替换为影子页表基地址，从而让 MMU 直接解析 GVA。 VMM 需要监视虚拟机对页表的更改，并对应地修改影子页表。同时为了分隔用户态和内核态，需要分离对应的页表，使得用户态页表中不包含内核态的映射 缺页处理： 若为页表项不存在或无权限，VMM 需触发宿主 OS 的缺页中断进行处理 若为访问权限足够，则需要同步影子页表与虚拟机页表 直接页表映射 客户端与宿主共用页表。该情况下客户端知道自己处在虚拟环境中，VMM 会告知客户端可以使用的页表范围，方便客户端规划。客户端的页表项被设为只读，修改页表需要使用 VMM 提供的超级调用，该调用会检查对页表的修改是否合法。 两阶段地址翻译 硬件虚拟化的一部分，需要 CPU 支持使用第二页表将 GPA 转换到 HPA，省去 VMM 手动维护影子页表的步骤。同时可以使用 TLB 来优化解析速度。 缺页中断处理： 客户虚拟机缺页：无需下陷，硬件直接调用虚拟机注册的中断函数 第二阶段页表缺页：下陷，硬件直接调用 VMM 注册的的对应中断函数 优点： 不用维护影子页表 不用为每个进程维护一个页表 缺页处理更快 换页和内存气球 目的：运行时动态调整虚拟机内存大小，内存超售 换页逻辑： 保存将要交换的页的 GVA 和 GPA 交换页内数据到持久化存储设备（硬盘什么的） 将客户端页表项设为 INVALID VMM 重新分配该页 内存气球(Memory Ballooning)：在客户端插入一个驱动(内鬼)，该驱动根据 VMM 的要求使用虚拟机的接口申请/释放内存，然后将申请的内存物理地址告诉 VMM 来使用。 I/O虚拟化 限制虚拟机对物理硬件的直接访问 提供虚拟设备接口 充分利用I/O 软件模拟（全虚拟化） 捕获客户端对虚拟硬件的 MMIO, DMA, 中断，下陷后由 VMM 执行对应操作 半虚拟化 类似全虚拟化，客户端不再使用原生驱动而是前端驱动，用于与 VMM 后端驱动交互。 通过内存共享传递数据，并使用批处理加速，由后端驱动完成和物理硬件的交互。 设备直通 让客户端直接管理硬件设备，此时操作对应硬件不会产生任何下陷。为防止 DMA 攻击使用 IOMMU 进行二阶段 GPA 到 HPA 的映射并检查对应权限。 SR-IOV(single root I/O virtualization):实现硬件层面 IO 虚拟化，避免单一虚拟机独占硬件。通过创建多个 VF （virtual function） 让 VMM 分配给虚拟机使用 中断虚拟化 两种中断： 物理中断：由硬件产生，在非直通情况下由 VMM 处理 虚拟中断：由 VMM 产生 解决开关中断下陷的问题：增加可供虚拟机修改中断而无需下陷的虚拟寄存器 直接向虚拟机发送中断：增加一个中断翻译表，用于将物理中断翻译为虚拟机对应的中断。因此无需再进行下陷。 QEMU/KVM 略","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://blog.vollate.top/tags/Notes/"},{"name":"OS","slug":"OS","permalink":"http://blog.vollate.top/tags/OS/"}]},{"title":"折腾网站记录","slug":"build-site","date":"2023-11-13T09:22:25.000Z","updated":"2024-09-26T04:58:26.000Z","comments":true,"path":"2023/11/13/build-site/","permalink":"http://blog.vollate.top/2023/11/13/build-site/","excerpt":"","text":"原来的 vps 到期了，不想续费新开了一台，忘了全系统备份。索性 blog 扔到 github page,然后又是一顿折腾。 Github Action 样例 改了改 Hexo 官网的: 1234567891011121314151617181920212223242526272829name: Blogon: push: branches: - mainjobs: pages: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; submodules: true - name: Use Node.js 18.x uses: actions/setup-node@v2 with: node-version: &quot;18&quot; - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./public Github Action 禁用 jekyll build 因为要用 peaceiris/actions-gh-pages@v3 进行部署，但是用的 Hexo 且已经在先前的操作编译完成，只需部署到对应分支即可。 一开始不知道 debug 了半天 解决方法在仓库里创建一个.nojekyll文件即可, 这会自动禁用 jekyll build 而只执行 deploy (部署编译好的文件到对应分支) 使用cf后无限redirect 在 namesilo 买的域名，突发奇想试试用 Cloudflare 免费计划的域名解析（为了CDN） 配完后炸了，http 请求返回 301 导致无限 redirect，查了下原因如下： 服务器端使用了强制HTTPS，CloudFlare 的Flexible策略原理是：用户访问时使用HTTPS访问到CF的节点，然后CF通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF就是访客，所以服务器返回的状态都是 301。解决方法很简单，将 SSL 策略设为 Full 或者 Full(strict) 就能解决。 Vanishvzone.me/897 不要给网盘套 cf 的 cdn cf 的 cdn 有单文件100M 大小限制，为了不被滥用。写 dns 的时候脑子抽了，然后虚空 debug nginx 配置文件。 上大学上的.jpg","categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://blog.vollate.top/tags/Blog/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://blog.vollate.top/tags/CI-CD/"}]},{"title":"More Effecitve C++","slug":"more-effecitve-cpp","date":"2023-11-08T08:21:57.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2023/11/08/more-effecitve-cpp/","permalink":"http://blog.vollate.top/2023/11/08/more-effecitve-cpp/","excerpt":"","text":"不能直接往数组类容器塞多态类，使用指针；一定要引用的情况下（需要operator()）用std::reference 直接创建数组或用vector,array等容器预先分配大小时调用类的无参(默认)构造函数，因此如果用了explict记得声明无参构造函数 1234567//没有无参构造函数解法（别用）class Ex;void* ptr=operator new[](10*sizeof(Ex));for(int i=0;i!=10;++i) new (&amp;ptr[i]) Ex(...);//call constructor//Free memoryoperator delete(ptr); custom i++&amp;++i for class class foo;int foo operator++();//++iconst int foo operator++(int);//i++ 尽可能不重载 &amp;&amp;,|| and ,，因为不满足短路逻辑 有关new, new[],delete,delete[] new时，先调用void* operator new(size_t size)分配内存,然后初始化对象并且将void*转型为对应类型指针 operator new 的一个重载:void* operator new(size_t size, void* loaction) 定位new实现 delete时，先调用析构函数然后operator delete 释放内存 对数组: new []调用operator new[]()分配内存,然后为每个对象调用构造函数 delete[]同理 构造函数异常处理(未完全构造函数不会栈解退自动析构): 使用try catch进行清理 防止成员列表初始化const pointer异常导致资源泄漏的方法(未完全构造指针无法使用delete): 调用一个basic exception guarantee的函数 使用RAII类 异常 异常栈解退时调用析构函数再抛出异常将会导致程序直接终止(call terminate directly kill program) 异常拷贝时按照静态类型拷贝(派生类的基类引用拷贝为基类) 异常捕获的支持隐式转型(按指): 任何指针to void*(极其不建议用指针) 派生类转基类 总是按catch先后顺序捕获 按引用捕获可以实现多态 Improve proformance: lazy evaluation: 返回一个结果的代理类，只有在需要时才进行计算 lazy copy： 写时复制 lazy fetch：涉及到数据库的部分 over-eager evaluation：提前计算并存入缓存，或constexpr编译期计算 临时对象: 仅在按值传递对象或者传递常量引用参数时产生。返回对象时，若直接返回则会拷贝局部对象 返回值优化: 返回构造函数的参数，这样返回的对象会在返回的作用域构造(编译器优化) 判断类是否在堆中(为了确定能否调用delete this)：重载operator new,operator new[],记录返回的指针到一个图中，每次删除前进行查找是否在堆上 适当使用代理可以简化流程，但是会在隐式转型的地方出错 类型擦除:使用虚基类(接口) double dispatch:(针对不同动态类型的多个object产生不同副作用) 虚函数 + RTTI：无封装，可维护性为0 多重虚函数调用: 类似模板递归展开的手动实现，每次确定一个类型，然后调用下一个虚函数 手动实现虚函数表","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://blog.vollate.top/tags/Notes/"},{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/tags/C/"}]},{"title":"CPP 随笔","slug":"cpp-essay","date":"2023-11-03T03:20:31.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2023/11/03/cpp-essay/","permalink":"http://blog.vollate.top/2023/11/03/cpp-essay/","excerpt":"","text":"记录cpp编程过程中的一些总结 clang + libstdc++ debug 问题 众所周知 LLVM 的 libc++ 和 GNU 的 libstdc++ 是两个不同的标准库实现。虽然使用 clang + libstdc++ 编译也可以使用 LLDB 对程序进行 debug，但是字符串以及一些数据结构如 unordered_map 无法正确显示值。解决方式: 使用编译选项 “-fstandalone-debug” 在编译和链接时换为 libc++, cmake 中可以使用 set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;) 来解决。 cheatsheet: cmake 中切换到 llvm 全套 C++ 工具链 if(&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot; STREQUAL &quot;Clang&quot;) set(CMAKE_CXX_FLAGS &quot;-stdlib=libc++&quot;) set(CMAKE_EXE_LINKER_FLAGS &quot;-fuse-ld=lld&quot;)endif ()","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://blog.vollate.top/tags/Notes/"},{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/tags/C/"}]},{"title":"Effective C++","slug":"effective-cpp","date":"2023-10-05T08:03:48.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2023/10/05/effective-cpp/","permalink":"http://blog.vollate.top/2023/10/05/effective-cpp/","excerpt":"","text":"从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了( Items from 1 to 55 将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择不同的编程方式 能用const，enum，inline就别#define 能用const就用const 确保类初始化后再使用 尽可能使用列表初始化(原因:operator= first call class’s default consturctor to allocate memory and get address, then do variable assigment) 避免初始化顺序问题（有关static初始化的问题） 知道默认构造，析构，复制构造函数 一旦创建移动构造||移动赋值操作符，不会生成默认复制构造&amp;&amp;复制运算符，反之亦然 小心使用默认生成的类函数 若要使用多态，则应将基类析构函数定义为virtual 不要让异常离开析构函数 不要在构造和析构函数中调用虚函数 也不是不能用，注意用的时候的类型是基类还是派生类（容易出问题所以不建议用） 重载运算符建议返回*this以便连等及其它操作 重载操作符时要考虑自己对自己操作的情况 处理方法： 先判断地址 拷贝后操作拷贝 拷贝（复制运算符）要完全复制类的内容（包括基类的） 要复用代码，不要相互调用复制构造函数，而是共同调用一个三方函数 RAII: use class to manage resource(unique_ptr &amp; share_ptr) RAII object have specified copy function 访问RAII class数据： 隐式：更方便 显示：更安全 成对使用对应的 new([]) &amp; delete([]) 单独创建智能指针 eg: A(std::unique_ptr&lt;B&gt;(new B), fuc()) 智能指针创建需要接受 new 返回的地址，而类构造函数执行顺序由编译器决定，如果fuc throw exception,会导致内存泄漏 设计良好的interface 尽可能不让用户写出出错代码 减少用户碰到管理内存的几率 shared_ptr总是使用指向类的析构函数，可以防止cross-DLL(object creat in a dynamic link library but delete in a differet DLL) 定义类就是定义类型，关注一些细节 尽量传const&amp;,对基础类型直接传值(iterator实现是指针，也算) 不要返回指向本地临时变量的指针 对用户隐藏数据，protected没比public包装好到哪去 不用访问data的就别搞成成员函数 类型转换需要非成员函数(friend) 创建合适的swap函数： 默认的std::swap执行三次拷贝构造-&gt;解决方案：构造wapper类使用指针来存储数据，交换仅交换指针，并且提供public的swap成员函数 如果该类不是模板类，需要具体化std::swap给该类;如果该类是模板类则在namespace中重写swap（模板函数） 调用规则：using + using std::swap，调用优先级为 模板swap&gt;具体化std::swap&gt;std::swap,因此记得using 和using std::swap 尽可能延缓变量的定义（看情况而定）好处： - 避免无用变量构造消耗时间（throw会导致无用 - 优化默认构造+复制构造为复制构造 尽可能不用cast，尤其dynamic_cast；必须要用，定义函数来隐藏cast（尽量避免用户自己cast）；少用c类型的转型, c++四种cast const_cast dynamic_cast reinterpret_cast static_cast static_cast子类转成父类时是产生一个子类中父类的临时拷贝，修改不会映射到原存储 cast要小心，搞清楚自己的目的 尽可能避免返回句柄[引用和指针] 指向栈中临时变量会寄掉 exception safety: No resource leak No data structures become coorupted exception safety function: Basic guarantee: after throw, everything in program remain valid Strong guarantee: after exception, the program status remain as if the fuction is never called Nothrow guarantee: never throw exception(hard to guarantee out of C part in C++) Strong guarantee implement: make a copy and modify the copy, then swap them in noexception way(But this need more resource and time, though it’s highly recommand, not always need to provide strong guarantee) 一般函数需要提供至少要有weak exception guarantee(at least no resource leak) inline function rules: limit inline function as small, frequently called functions. 内联别用模板 其它一些东西： 一般构造和析构函数不是内联 能不能内联主要看编译器 最小化编译依赖关系（通过声明）可以使用： handle class interface class: increase memory cost for virtual function table 编译时只需要重新链接函数就行 public inheritance means “is a”(noted that only public do this) 继承会隐藏父类（作用域）的变量和函数（当然名称空间也会{使用using解除隐藏 pure virtual function; virtual function;non-virtual function; 不要担心虚函数带来的损耗（大多数情况），也不要全是虚函数（一样） pure virtual function可以在类外提供实现，如此可以强制子类重写（算是强制注意吧）并减少代码重复 80~20rule:80% running time spend on 20% code 使用none virtual interface idiom 在基类以确保多态在何时调用函数 使用函数指针成员代替虚函数（好处：可以更改调用的函数(坏处：缺少对非public变量的访问权限 使用std::function成员代替虚函数 重定义非虚函数可能会使得多态出现意想不到的问题(从设计上来说就不应该重定义非虚函数) 默认参数值为静态绑定，不同于虚函数的动态绑定，不要在继承中改变默认值 has a &amp; implemented in terms of-- composition private inheritance当仅必要时 - both private inheritance and composition mean is-implemented-in-terms-of - composition is easy to understand - private inheritance can enable EBO - empty base optomize(EBO):当仅单继承且父类是空类时，子类大小等于数据大小(编译器优化 多继承尽量别用，用要考虑virtual 虚拟继承有损耗（比起单继承 多继承例子：public interface+private implementation 类和模板都支持多态 对于类，接口是明确的，多态出现在运行时 对于模板参数，接口是明确且基于合法的表达式的，多态出现在编译时（通过模板初始化和函数重载） typename和class可以互换 在不清楚的情况下，C++默认把typename(class):😗**看成变量而不是类型，使用 typename 告诉他这是个变量类型 访问模板基类函数的三种方法 使用 this 指针调用 using 指令 base&lt;T&gt;::**直接用 模板隐式具体化出的不依赖于模板参数的函数会导致程序膨胀 若由非类型参数导致，将模板参数换为函数参数或者类成员变量 若由类型参数导致，可以将数据转化为 无类型指针 eg: static_cast&lt;void*&gt; 然后统一调用 在模板类中使用模板成员函数来接受所有合法参数 eg: 同模板不同具体化类的实例化的复制构造函数和复制运算符 注意：即使声明了模板复制构造函数，也要声明一般的复制构造函数 我不知道他想说明啥 特化模板类使其对特定类型使用特定函数 通过 tyepid() 检查—wrong, can’t compile 由于不同的类型支持不同的函数，一些不支持的函数无法被编译（即使if else永远不会进入)编译过程要求所有代码合法 通过和函数重载(编译时) TMP(template metaprogramming) 将一部分运行时工作放到编译时进行 通过 set_new_handler(*new_handler) 自定义new的行为 typedef void (*new_handler)() declear in std, use as std::new_handler 通过连锁调用在失败后尝试其他 handler 分配内存，最后全部失败再throw bad_alloc 自定义类new的行为: modify void* operator new(std::size)throw(std::bad_alloc) and set_new_handler C++93前new分配失败会返回0，使用 new(std::nothrow) 来启用这一行为（只作用于内存分配时，初始化相关对象仍可能throw 重载new/delete操作符的几种情况 优化操作速度 收集内存使用信息 减少开头和末尾的内存占用 自定义内存对齐 将类集束摆放 其他未列出new行为 重载new和delete 重载new需要一个无限循环来分配内存，并在失败时调用 set_new_handler 或者分配0空间并throw 对于类类型，应该分配比预期更大空间 delete对nullptr什么也不做，对类类型应该删除比预期更大空间 重写new了记得重写delete，并且不要无意间隐藏了默认的new&amp;delete 注意编译警告，也不要过度依赖编译器 熟悉标准库，包括 STL(standard template library) Iostream Internationlization(like wchar_t,wstring) numeric provessing(valarray, complex) exception hierarchy C89 standard library tr1(2005,Technical report 1), add smartPointers,function pointers(tr1::function,std::function now)就是std::expermental::xxx Boost organization and Boost library This is just a begining, C++ learning will never end","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://blog.vollate.top/tags/Notes/"},{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/tags/C/"}]},{"title":"Book List","slug":"book-list","date":"2023-08-30T07:33:26.000Z","updated":"2024-03-03T10:46:58.000Z","comments":true,"path":"2023/08/30/book-list/","permalink":"http://blog.vollate.top/2023/08/30/book-list/","excerpt":"","text":"Reading C++ Currency in Action Schedule Effective Modern C++ C++ Templates ed.2 Stash Deep learning Finished Name Finish date C++ Primer Plus 2021.12 Effective C++ 2022.7 1984 2022.6 沙丘 2022.6 资本论 2022.8.1 地铁系列(203[3,5]) 2022.9.25 More Effective C++ 2023.1.22 The Fast Guide towards Modern C++ 2023.7.15","categories":[],"tags":[{"name":"Books","slug":"Books","permalink":"http://blog.vollate.top/tags/Books/"}]},{"title":"Tool List","slug":"tool-list","date":"2023-03-27T00:17:41.000Z","updated":"2024-07-06T09:56:57.000Z","comments":true,"path":"2023/03/27/tool-list/","permalink":"http://blog.vollate.top/2023/03/27/tool-list/","excerpt":"","text":"收录了Linux下使用的一些工具 Screen Shot/Recorder SimpleScreenRecorder OBS studio Flameshot Cloud Drive Onedrive OnedriveGUI: GUI for client above Rclone: better than above Proxy Clash Client cfw(closed-source) 不建议使用 clash-verge(open-source) clash verge rev; 因为某些烂人的原因，被铁拳制裁后重生的版本 注意 Clash 和 Clash.Meta 是开源软件，clash.Premium 为 Clash 原作者在 Clash 基础上开发的闭源软件，介意误用 只剩 Meta 了且改名了。原神，启动!!! V2ray Client v2rayA(open-source) Diagram drawio Office libreoffice onlyoffice xournal++ 全平台手写板工具，但是安卓端还很烂 Resource Monitor btop or bpytop htop Diff Tools meld kdiff3 Mouse piper 解决了 LogitechG 系列鼠标在 Linux 下无法设置 DPI，灯光不亮的问题。相当于一个非官方 Logitech G Hub","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"}]},{"title":"Article Archive","slug":"article-archives","date":"2022-11-10T20:10:57.000Z","updated":"2024-02-15T14:09:46.000Z","comments":true,"path":"2022/11/10/article-archives/","permalink":"http://blog.vollate.top/2022/11/10/article-archives/","excerpt":"","text":"OS 内存管理 Program CMake export lib oneAPI|DPC++归档 CppCon Network GFW report","categories":[],"tags":[{"name":"Archive","slug":"Archive","permalink":"http://blog.vollate.top/tags/Archive/"}]},{"title":"Happy Runner (乐道不跑)","slug":"happy-runner","date":"2022-11-03T02:57:19.000Z","updated":"2024-05-10T18:01:09.000Z","comments":true,"path":"2022/11/03/happy-runner/","permalink":"http://blog.vollate.top/2022/11/03/happy-runner/","excerpt":"","text":"Requirement 一部root了的安卓手机(解不了bl的可以试试太极) 如何root建议google,据说小米开模糊定位不root也行，但是没试过(没有没root的手机) Steps 下载fake location，链接挂了就上 github 搜 买高级版 (花钱) 设置里面把地图换成百度 路线模拟里面画路线，建议把每个可能的打卡点都过一遍 现在不用打卡了,差不多就行，注意别超过单次最大路程 开启路线模拟和乐跑，设置速度(注意别太快了)，建议开启浮动速度和模拟步频 记得到时间来关乐跑免得超时 问题排查 开了模拟没反应: 换运行模式(root/no root) 乐跑闪退(root了的手机/模拟器): 对乐跑隐藏root(Magisk/fake location 内置) 目前最新版乐跑好像不能在模拟器中运行，大概是检测模拟器？ 其他: 看文档, google，我有一个朋友 本教程仅供参考，使用有风险，对于按照本教程操作造成被检测等等问题概不负责","categories":[{"name":"Trick","slug":"Trick","permalink":"http://blog.vollate.top/categories/Trick/"}],"tags":[]},{"title":"First Post","slug":"first-post","date":"2022-10-01T03:12:59.000Z","updated":"2023-12-08T07:34:57.000Z","comments":true,"path":"2022/10/01/first-post/","permalink":"http://blog.vollate.top/2022/10/01/first-post/","excerpt":"","text":"总算整了个能看的 blog 界面 之前搭图床然后疯狂报错 最后发现发现设置 nginx 的时候 location 拼错了 不开语法高亮的下场 总之捣鼓了快一个月想起来弄一下断断续续的终于配好了","categories":[],"tags":[]}],"categories":[{"name":"Journal","slug":"Journal","permalink":"http://blog.vollate.top/categories/Journal/"},{"name":"Knowledge","slug":"Knowledge","permalink":"http://blog.vollate.top/categories/Knowledge/"},{"name":"Trick","slug":"Trick","permalink":"http://blog.vollate.top/categories/Trick/"}],"tags":[{"name":"Singbox","slug":"Singbox","permalink":"http://blog.vollate.top/tags/Singbox/"},{"name":"Android","slug":"Android","permalink":"http://blog.vollate.top/tags/Android/"},{"name":"Proxy","slug":"Proxy","permalink":"http://blog.vollate.top/tags/Proxy/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.vollate.top/tags/Linux/"},{"name":"Systemd","slug":"Systemd","permalink":"http://blog.vollate.top/tags/Systemd/"},{"name":"CMake","slug":"CMake","permalink":"http://blog.vollate.top/tags/CMake/"},{"name":"Server","slug":"Server","permalink":"http://blog.vollate.top/tags/Server/"},{"name":"Emali","slug":"Emali","permalink":"http://blog.vollate.top/tags/Emali/"},{"name":"Password","slug":"Password","permalink":"http://blog.vollate.top/tags/Password/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.vollate.top/tags/Docker/"},{"name":"LLDB","slug":"LLDB","permalink":"http://blog.vollate.top/tags/LLDB/"},{"name":"Notes","slug":"Notes","permalink":"http://blog.vollate.top/tags/Notes/"},{"name":"RPC","slug":"RPC","permalink":"http://blog.vollate.top/tags/RPC/"},{"name":"KDE Plasma","slug":"KDE-Plasma","permalink":"http://blog.vollate.top/tags/KDE-Plasma/"},{"name":"Compiler","slug":"Compiler","permalink":"http://blog.vollate.top/tags/Compiler/"},{"name":"OS","slug":"OS","permalink":"http://blog.vollate.top/tags/OS/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.vollate.top/tags/Blog/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://blog.vollate.top/tags/CI-CD/"},{"name":"C++","slug":"C","permalink":"http://blog.vollate.top/tags/C/"},{"name":"Books","slug":"Books","permalink":"http://blog.vollate.top/tags/Books/"},{"name":"Archive","slug":"Archive","permalink":"http://blog.vollate.top/tags/Archive/"}]}