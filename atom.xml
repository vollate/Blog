<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vollate&#39;s Blog</title>
  
  
  <link href="http://blog.vollate.top/atom.xml" rel="self"/>
  
  <link href="http://blog.vollate.top/"/>
  <updated>2025-04-26T19:12:34.000Z</updated>
  <id>http://blog.vollate.top/</id>
  
  <author>
    <name>Vollate</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Clash 迁移到 Sing-Box</title>
    <link href="http://blog.vollate.top/2025/04/26/clash2singbox/"/>
    <id>http://blog.vollate.top/2025/04/26/clash2singbox/</id>
    <published>2025-04-26T10:31:17.000Z</published>
    <updated>2025-04-26T19:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前就了解到 Sing-Box 了，但是人一直很懒，clash-verge-rev 配置没怎么改就懒得换（不得不提用 Tauri 写的 GUI 真的各种奇奇怪怪的问题）。今天爆了 service 提权漏洞，索性换到 Singbox 了。</p><p>Sing-Box 自身在桌面端没有成熟的 GUI，只有 CLI, 这里选用 <a href="https://gui-for-cores.github.io/zh/">GUI for Cores</a>，支持多种 kernel。</p><p>Sing-box 作为重新实现的新内核，支持大多数代理协议，内存占用更低。同时没有 clash-* 那么多历史包袱并且完全开源，安全性更高。</p><h2 id="安装">安装</h2><p>笔者的系统是 X64 Arch Linux，内核是 <code>Linux 6.14.3-arch1-1</code>,使用 NetworkManager 管理网络,防火墙是 <code>firewalld</code>。</p><p>作为 Arch 用户，最先尝试的肯定是 AUR 包了，装了发现并不是最新（2025-04-26)，看了下 Github 上的二进制 release 内置滚动更新，直接下载了二进制包。</p><p>单独创建一个目录解压后丢进去，配置照着<a href="https://gui-for-cores.github.io/zh/guide/gfs/community">官方文档</a>就行了。</p><h2 id="问题-解决">问题&amp;解决</h2><h3 id="防火墙放行-tun-设备">防火墙放行 tun 设备</h3><p>和mihomo(clash-meta)不同，singbox 注册 tun 设备的方式是通过 netlink 的方式注册的，这就导致 NetworkManager 会自动将其注册为一个新的 Connection 而不是 mihomo 的 interface 设备，每次的 uuid 会变化，无法设置 firewalld zone 规则。</p><p>解决方法是在 <code>/etc/NetworkManager/conf.d/</code> 目录下创建一个&quot;xxx.config&quot;配置文件:</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[keyfile]</span></span><br><span class="line"><span class="attr">unmanaged-devices</span>=interface-name:&lt;Your tun interface name&gt;</span><br></pre></td></tr></table></figure><p>将 <code>&lt;Your tun interface name&gt;</code> 替换为你实际的 tun 设备名称,这个在 Singbox 的配置文件中可以找到，如果是 GUI for singbox 则是在的 profile中配置（记得启用），然后重新加载 NetworkManager:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload NetworkManager</span><br></pre></td></tr></table></figure><p>然后在 firewalld 中添加规则并重启:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=trusted --add-interface=&lt;Your tun interface name&gt;</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>这样 <code>NetworkManager</code> 就不会管理这个设备尝试为其创建 Connection，firewalld 便可以根据 interface-name 设置 zone 规则了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很早以前就了解到 Sing-Box 了，但是人一直很懒，clash-verge-rev 配置没怎么改就懒得换（不得不提用 Tauri 写的 GUI 真的各种奇奇怪怪的问题）。今天爆了 service 提权漏洞，索性换到 Singbox 了。&lt;/p&gt;
&lt;p&gt;Sing-Box </summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Singbox" scheme="http://blog.vollate.top/tags/Singbox/"/>
    
    <category term="Proxy" scheme="http://blog.vollate.top/tags/Proxy/"/>
    
    <category term="Linux" scheme="http://blog.vollate.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Systemd network-online.target 问题排查记录</title>
    <link href="http://blog.vollate.top/2024/12/02/systemd-network-online-problem/"/>
    <id>http://blog.vollate.top/2024/12/02/systemd-network-online-problem/</id>
    <published>2024-12-02T12:46:13.000Z</published>
    <updated>2024-12-02T12:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><s>clash verge rev</s> 某不存在的软件更新到 2.0 后，启动时会安装 systemd 服务用于 TUN 网络代理。但升级后每次都需要重新执行 <code>uninstall-service</code> 和 <code>install-service</code>, 且必定会卡死一段时间。这里记录一下排查过程。</p><h2 id="检查为何要执行-uninstall-service-和-install-service">检查为何要执行 <code>uninstall-service</code> 和 <code>install-service</code></h2><p>查看<a href="https://github.com/clash-verge-rev/clash-verge-rev/blob/ae5b2cfb79423c7e76a281725209b812774367fa/src-tauri/src/core/service.rs#L76">源码</a>得知，service 安装由这个函数执行，检查调用他的 <a href="https://github.com/clash-verge-rev/clash-verge-rev/blob/ae5b2cfb79423c7e76a281725209b812774367fa/src-tauri/src/core/service.rs#L163"><code>check_service</code></a> 函数发现对 “SERVICE_URL/get_clash” 发 GET 请求来检测服务是否运行。 “SERVICE_URL” 是一个常量,为 “<a href="http://127.0.0.1:33211">http://127.0.0.1:33211</a>”</p><p>lsof 看看是什么进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo lsof -i :33211</span><br><span class="line">COMMAND   PID USER FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">clash-ver 738 root 9u  IPv4   5515      0t0  TCP localhost:33211 (LISTEN)</span><br><span class="line">❯ sudo lsof -p 738</span><br><span class="line">lsof: WARNING: can&#x27;t stat() fuse.portal file system /run/user/1001/doc</span><br><span class="line">      Output information may be incomplete.</span><br><span class="line">COMMAND   PID USER  FD      TYPE             DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">clash-ver 738 root cwd       DIR              259,6     4096       2 /</span><br><span class="line">clash-ver 738 root rtd       DIR              259,6     4096       2 /</span><br><span class="line">clash-ver 738 root txt       REG              259,6  1068272 4667021 /usr/bin/clash-verge-service</span><br><span class="line">clash-ver 738 root mem       REG              259,6  2014520 4590980 /usr/lib/libc.so.6</span><br><span class="line">clash-ver 738 root mem       REG              259,6    14280 4590996 /usr/lib/libdl.so.2</span><br><span class="line">clash-ver 738 root mem       REG              259,6   973144 4591006 /usr/lib/libm.so.6</span><br><span class="line">clash-ver 738 root mem       REG              259,6    14288 4591034 /usr/lib/libpthread.so.0</span><br><span class="line">clash-ver 738 root mem       REG              259,6    14352 4591039 /usr/lib/librt.so.1</span><br><span class="line">clash-ver 738 root mem       REG              259,6   915712 4591699 /usr/lib/libgcc_s.so.1</span><br><span class="line">clash-ver 738 root mem       REG              259,6   228376 4590929 /usr/lib/ld-linux-x86-64.so.2</span><br><span class="line">clash-ver 738 root   0r      CHR                1,3      0t0       4 /dev/null</span><br><span class="line">clash-ver 738 root   1u     unix 0x000000005430ea85      0t0   17938 type=STREAM (CONNECTED)</span><br><span class="line">clash-ver 738 root   2u     unix 0x000000005430ea85      0t0   17938 type=STREAM (CONNECTED)</span><br><span class="line">clash-ver 738 root   3u  a_inode               0,16        0    2087 [eventpoll:4,8,9]</span><br><span class="line">clash-ver 738 root   4u  a_inode               0,16        0    2087 [eventfd:0]</span><br><span class="line">clash-ver 738 root   5u  a_inode               0,16        0    2087 [eventpoll:4,8,9]</span><br><span class="line">clash-ver 738 root   6u     unix 0x00000000cb59cf7b      0t0    2387 type=STREAM (CONNECTED)</span><br><span class="line">clash-ver 738 root   7u     unix 0x00000000093de046      0t0    2388 type=STREAM (CONNECTED)</span><br><span class="line">clash-ver 738 root   8u     unix 0x00000000cb59cf7b      0t0    2387 type=STREAM (CONNECTED)</span><br><span class="line">clash-ver 738 root   9u     IPv4               5515      0t0     TCP localhost:33211 (LISTEN)</span><br></pre></td></tr></table></figure><h2 id="检查服务状态">检查服务状态</h2><p>看看装了哪些服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ systemctl list-units|grep clash</span><br><span class="line">  clash-verge-service.service</span><br></pre></td></tr></table></figure><p>使用 <code>systemctl status clash-verge-service.service</code> 查看服务状态和文件位置，打开后如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash Verge Service helps to launch Clash Core.</span><br><span class="line">After=network-online.target nftables.service iptables.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/clash-verge-service</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>Systemd serive 定义中，<code>After=network-online.target nftables.service iptables.service</code> 表明至少一个服务完成启动后才会启动 clash-verge-service。<br>我的系统使用 <code>firewalld</code> 作为防火墙,它会作为上层服务自动启用 <code>nftables.service</code> 和 <code>iptables.service</code> 作为底层服务，所以 <code>nftables.service iptables.service</code> 两个服务不会启动，因此只需要等待 <code>network-online.target</code> 启动完成即可。</p><h2 id="测试-network-online-target">测试 network-online.target</h2><p>执行 <code>systemctl start network-online.target</code>，发现会卡死将近 2 min。使用 <code>systemd-analyze critical-chain network-online.target</code> 检查依赖和耗时，发现实际执行(CPU 时间)正常，但是启动前经过了长时间等待。</p><p>接下来查了下 <code>network-online.target</code> 的依赖和被依赖，没什么问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">❯ systemctl list-dependencies network-online.target --after</span><br><span class="line">network-online.target</span><br><span class="line">○ ├─NetworkManager-wait-online.service</span><br><span class="line">● └─network.target</span><br><span class="line">●   ├─dhcpcd.service</span><br><span class="line">●   ├─NetworkManager.service</span><br><span class="line">●   ├─systemd-networkd.service</span><br><span class="line">●   ├─wpa_supplicant.service</span><br><span class="line">●   └─network-pre.target</span><br><span class="line">●     ├─firewalld.service</span><br><span class="line">○     ├─ip6tables.service</span><br><span class="line">○     ├─iptables.service</span><br><span class="line">○     ├─nftables.service</span><br><span class="line">●     └─systemd-network-generator.service</span><br><span class="line"></span><br><span class="line">❯ systemctl list-dependencies network-online.target --before</span><br><span class="line">network-online.target</span><br><span class="line">○ ├─archlinux-keyring-wkd-sync.service</span><br><span class="line">● ├─clash-verge-service.service</span><br><span class="line">○ ├─docker.service</span><br><span class="line">○ └─shutdown.target</span><br><span class="line">○   ├─systemd-halt.service</span><br><span class="line">○   ├─systemd-kexec.service</span><br><span class="line">○   ├─systemd-poweroff.service</span><br><span class="line">○   ├─systemd-reboot.service</span><br><span class="line">○   ├─systemd-soft-reboot.service</span><br><span class="line">○   └─final.target</span><br><span class="line">○     ├─systemd-halt.service</span><br><span class="line">○     ├─systemd-kexec.service</span><br><span class="line">○     ├─systemd-poweroff.service</span><br><span class="line">○     ├─systemd-reboot.service</span><br><span class="line">○     └─systemd-soft-reboot.service</span><br></pre></td></tr></table></figure><p>同样，执行任何依赖于 <code>network-online.target</code> 的服务都会卡死将近 2 min（我就说我 docker.service 为什么启动慢）</p><p>参考 <a href="https://systemd.io/NETWORK_ONLINE/">systemd.io</a>，可以知道在使用 systemd 的系统中，<code>network-online.target</code> 一般会在网络连接成功后启动,用于确保服务在网络连接成功后启动来。如需要进行远程磁盘挂载、远程数据库连接等操作，可以将服务依赖于 <code>network-online.target</code>。<br><code>network-online.target</code> 主要通过 <code>NetworkManager-wait-online.service</code> 或 <code>systemd-networkd-wait-online.service</code> 来启动。我使用的是 NetworkManager，所以应该是 <code>NetworkManager-wait-online.service</code>。<br>在 “To verify that the right service is enabled (usually only one should be):” 章节中提到了可以使用如下命令验证 service 正常配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl is-enabled NetworkManager-wait-online.service systemd-networkd-wait-online.service</span></span><br><span class="line">disabled</span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>经排查发现同时启用了 <code>NetworkManager-wait-online.service</code> 和 <code>systemd-networkd-wait-online.service</code>，导致了问题。禁用 <code>systemd-networkd-wait-online.service</code> 后，<code>network-online.target</code> 启动正常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;s&gt;clash verge rev&lt;/s&gt; 某不存在的软件更新到 2.0 后，启动时会安装 systemd 服务用于 TUN 网络代理。但升级后每次都需要重新执行 &lt;code&gt;uninstall-service&lt;/code&gt; 和 &lt;code&gt;install-service</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Linux" scheme="http://blog.vollate.top/tags/Linux/"/>
    
    <category term="Systemd" scheme="http://blog.vollate.top/tags/Systemd/"/>
    
  </entry>
  
  <entry>
    <title>CMake 从入门到能用就行</title>
    <link href="http://blog.vollate.top/2024/10/12/cmake-introduction/"/>
    <id>http://blog.vollate.top/2024/10/12/cmake-introduction/</id>
    <published>2024-10-12T17:49:55.000Z</published>
    <updated>2024-10-13T10:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建系统发展历史">构建系统发展历史</h2><ol><li>手工编译 (1950s - 1960s): 编程语言刚刚诞生，程序员需要手工编译程序，将源代码转换为机器码。</li><li>批处理脚本 (1960s - 1970s)： 使用批处理脚本或 shell 脚本自动化编译命令，减少了手工输入。</li><li>Make 系统 (1970s)： Make 引入了增量编译的概念，只重新编译修改过的文件，大幅提升效率。</li><li>配置和生成工具 (1980s - 1990s)： Autotools 等工具通过自动生成跨平台的构建脚本，支持多平台开发，避免了手写 Makefile 的情况。</li><li>现代构建系统 (2000s - 2010s)： CMake 和 Meson 等工具采用声明式语法，简化了复杂项目的构建过程。</li><li>专用构建系统和构建工具链 (2010s - Present)：Ninja、Gradle、Bazel、Buck 等专注于加速大型项目的构建，提供高度的自定义功能。</li><li>云原生和分布式构建 (2010s - Now)： 支持云原生和分布式开发场景的构建系统，集成了容器化和 CI/CD 工具。</li></ol><br/><p><strong>增量编译</strong>是指每次只编译修改过的编译单元，避免了无效编译。<br>例如，在 C/C++ 中，每个源文件对应一个编译单元，只有修改过的源文件才需要重新编译。同时由于预处理的原因，头文件的变更会递归影响到所有直接或间接引用该头文件的源文件。</p><h2 id="GNU-Make">GNU Make</h2><p>Make 是一个构建工具，通过 Makefile 文件定义项目的构建规则。Makefile 文件包含了一系列规则，每个规则由一个目标、依赖和命令组成。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variable</span></span><br><span class="line">CC = clang</span><br><span class="line">CFLAGS = -Wall -Wextra -Werror</span><br><span class="line"></span><br><span class="line"><span class="comment"># Target</span></span><br><span class="line"><span class="section">all: program</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c foo.c -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># $@ refers to the target</span></span><br><span class="line"><span class="comment"># $&lt; refers to the first dependency</span></span><br><span class="line"><span class="comment"># $^ refers to all dependencies</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">program: main.o foo.o</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> main.o foo.o -o program</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> subdir/Makefile</span><br></pre></td></tr></table></figure><p>make 是一个过程化的构建工具，需要手动书写构建命令，灵活度高但可维护性差。</p><h2 id="CMake">CMake</h2><p>CMake 作为元构建系统，可以生成 Make、Ninja、Visual Studio 等构建系统所需的配置文件，方便的实现项目的跨平台。CMake 的配置文件是 CMakeLists.txt，通过编写 CMakeLists.txt 文件，可以定义项目的构建规则。</p><h3 id="Version">Version</h3><p>cmake 不同版本之间的命令可能有所不同，新版可能会添加新的命令，并且会废弃一些旧的命令（但大部分情况仍然可用）, 所以在编写 CMakeLists.txt 文件时，需要限定 CMake 的最低版本。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>) <span class="comment"># minimum cmake version</span></span><br><span class="line"><span class="comment"># This is a line comment in cmake</span></span><br><span class="line"><span class="comment">#[[ This is a block comment in cmake ]]</span></span><br></pre></td></tr></table></figure><h3 id="Project">Project</h3><p>Project 命令用于定义项目的名称和支持的语言。对于支持的语言，可以使用 C、CXX、CUDA、Fortran、ASM 等。默认情况下，CMake 会自动检测项目中的源文件，并根据文件后缀名推断语言类型。</p><p>Project 支持设置项目的版本号，可以通过 VERSION 选项指定项目的版本号。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(hello_world) <span class="comment"># project name</span></span><br><span class="line"><span class="keyword">project</span>(hello_wrold VERSION <span class="number">5.14</span> LANGUAGES CXX CUDA) <span class="comment"># project name with languages</span></span><br></pre></td></tr></table></figure><h3 id="Variable">Variable</h3><p>CMake 中的变量分为如下几种：普通变量，缓存变量，环境变量。<br>普通变量仅在本次运行cmake期间有效；缓存变量会被存储到生成项目目录的 CMakeCache.txt 文件中，用途主要有以下几点：</p><ul><li>避免用户再次运行 cmake 重新设置变量</li><li>存储某些运行时信息，对用户不可见。如系统库的路径、编译器的路径等。</li></ul><p>环境变量取决于运行 cmake 的环境</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_FILES main.cpp lib.cpp) <span class="comment"># set Variable</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>) <span class="comment"># set Variable</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span> cache) <span class="comment"># set Cache Variable</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_STANDARD: $&#123;CMAKE_CXX_STANDARD&#125;&quot;</span>) <span class="comment"># print message</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;$ENV&#123;USER&#125;&quot;</span>) <span class="comment"># print warning message</span></span><br><span class="line"><span class="keyword">message</span>(ERROR <span class="string">&quot;Error message&quot;</span>) <span class="comment"># print error message</span></span><br></pre></td></tr></table></figure><p>CMAKE 中，所有变量都是字符串，访问不存在的变量会返回空（不是空字符串），如果无法正常处理会产生问题。因此常用的方法是使用 <code>if</code> 判断变量是否存在。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">DEFINED</span> CMAKE_CXX_STANDARD)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_STANDARD: $&#123;CMAKE_CXX_STANDARD&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(WARNING <span class="string">&quot;CMAKE_CXX_STANDARD is not defined&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>在比较时，则可以直接加上引号，这样即使变量不存在也不会报错。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;CMAKE_CXX_STANDARD&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;17&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_STANDARD is 17&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(WARNING <span class="string">&quot;CMAKE_CXX_STANDARD is not 17&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h3 id="Control-Flow">Control Flow</h3><p>同大部分编程语言一样，CMake 也支持条件判断和循环控制。</p><h4 id="if">if</h4><p>if 语句支持 AND、OR、NOT 逻辑运算符，可以使用 PARENT_SCOPE 选项将变量传递到父作用域。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CXX_STANDARD <span class="keyword">EQUAL</span> <span class="number">17</span> <span class="keyword">OR</span> ENABLE_CXX17)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_STANDARD is 17&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_CXX_STANDARD <span class="keyword">EQUAL</span> <span class="number">14</span> <span class="keyword">AND</span> CMAKE_CXX_STANDARD_REQUIRED)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;CMAKE_CXX_STANDARD is 14&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(WARNING <span class="string">&quot;CMAKE_CXX_STANDARD is not 17 or 14&quot;</span>) </span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>任何空字符串、0、FALSE、NOTFOUND、OFF、NO、N、IGNORE、无定义的变量都会被视为假，其他值都会被视为真。</p><h4 id="loop">loop</h4><p>CMake 支持 FOREACH、WHILE、WHILE、UNTIL 循环，其中 FOREACH 循环最为常用。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_FILES main.cpp lib.cpp a.cpp b.cpp)</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">file</span> <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;file&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><h3 id="Subdir">Subdir</h3><p>CMake 支持子目录，可以通过 add_subdirectory 命令添加子目录，子目录中的 CMakeLists.txt 文件会被执行。</p><p>eg：假设项目目录结构如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 1</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── 2</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>根目录的 CMakeLists.txt 文件如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(foo)</span><br><span class="line"><span class="keyword">set</span>(useless <span class="string">&quot;root&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Root: $&#123;useless&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Root: $&#123;useless&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Root: $&#123;useless&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Root: $&#123;useless2&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>1/CMakeLists.txt 文件如下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Dir1: $&#123;useless&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(useless <span class="string">&quot;dir1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Dir1: $&#123;useless&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>2/CMakeLists.txt 文件如下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(useless <span class="string">&quot;dir2&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">set</span>(useless2 <span class="string">&quot;dir2&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Dir2: $&#123;useless2&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行<code>cmake -Bbuild</code> 输出如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// something</span><br><span class="line">-- Root: root</span><br><span class="line">-- Dir1: root</span><br><span class="line">-- Dir1: dir1</span><br><span class="line">-- Root: root</span><br><span class="line">-- Dir2: dir2</span><br><span class="line">-- Root: dir2</span><br><span class="line">-- Root:</span><br><span class="line">// something</span><br></pre></td></tr></table></figure><p>可以看到，子目录中的变量不会影响到父目录，但是可以通过 PARENT_SCOPE 选项将变量传递到父目录。子目录调用完成后，返回到父目录，继续执行。</p><p>CMake 支持 include 命令，可以包含其他 CMakeLists.txt 文件。include 命令会将被包含的文件的内容直接插入到当前文件中，因此被包含的文件中定义的变量会影响到包含的文件。和 C/CPP的预处理#include 作用相同。</p><h3 id="Executable-Lib">Executable/Lib</h3><p>CMake 中支持三种类型的构建目标：可执行文件（add_executable）、静态库（add_library STATIC）、动态库（add_library SHARED）。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello_world main.cpp) <span class="comment"># add executable target</span></span><br><span class="line"><span class="keyword">add_library</span>(hello STATIC lib.cpp) <span class="comment"># add static library target</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED lib.cpp) <span class="comment"># add shared library target</span></span><br></pre></td></tr></table></figure><h3 id="include-directories">include_directories</h3><p>include_directories 命令用于添加头文件搜索路径，可以添加多个路径。使用 BEFORE 选项可以将路径添加到已有路径的前面，放置被其他路径覆盖。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>/foo) <span class="comment"># add include path</span></span><br><span class="line"><span class="keyword">include_directories</span>(BEFORE <span class="keyword">include</span>/bar) <span class="comment"># add include path before</span></span><br></pre></td></tr></table></figure><h3 id="target-xxx">target_xxx</h3><p>target_xxx 系列命令用于设置目标的属性，如编译选项、链接选项、依赖等。分为三种属性：PRIVATE, PUBLIC, INTERFACE。</p><ul><li>PRIVATE 属性只对当前目标有效, 不会传递给依赖目标</li><li>PUBLIC 属性对当前目标和依赖目标都有效</li><li>INTERFACE 属性只对依赖目标有效,不会对当前目标有效</li></ul><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello PUBLIC <span class="keyword">include</span>) <span class="comment"># add include path for target hello and any target that depends on hello</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(hello PRIVATE DEBUG) <span class="comment"># add compile definition for target hello</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello INTERFACE foo) <span class="comment"># link library foo to targets who depends on hello</span></span><br></pre></td></tr></table></figure><p>常用的 target_xxx 命令有：</p><ul><li>target_include_directories 添加头文件搜索路径</li><li>target_compile_definitions 添加编译宏定义</li><li>target_compile_options 添加编译选项</li><li>target_link_libraries 添加链接库</li></ul><h3 id="find-package">find_package</h3><p>find_package 命令用于查找外部库，有如下几种模式：</p><ul><li>Module 模式：在指定的路径下查找 <code>Find&lt;package&gt;.cmake</code> 文件，这个文件包含了查找库的规则，如何设置库的头文件路径、库文件路径、链接库等。</li><li>Config 模式：在指定的路径下查找 <code>&lt;package&gt;Config.cmake</code> 或 <code>&lt;lower-case-package&gt;-config.cmake</code> 文件，这个文件包含了库的配置信息，如头文件路径、库文件路径、链接库等。</li></ul><p>其他可选项</p><ul><li><code>REQUIRED</code>: 如果找不到库，CMake 会报错并停止构建。如果 <code>find_package</code> 成功，会定义一个 <code>&lt;package&gt;_FOUND</code> 变量，表示找到库。</li><li><code>OPTIONAL</code>: 如果找不到库，CMake 会继续构建。</li><li><code>QUIET</code>: 失败时不输出警告。</li><li><code>PATHS</code> &amp; <code>HINTS</code>: 指定查找路径，其中 <code>HINTS</code> 优先级高于 <code>PATHS</code>。</li><li><code>&lt;package&gt;_ROOT</code> 变量或环境变量如果设置，会优先使用。</li></ul><blockquote><p>具体查找顺序参考 <a href="https://cmake.org/cmake/help/latest/command/find_package.html#find-package">CMake 官方文档</a> 💩</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost) <span class="comment"># find boost library</span></span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Boost found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Boost not found&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV CONFIG REQUIRED) <span class="comment"># find opencv library</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenGL REQUIRED HINTS /usr/lib) <span class="comment"># find opengl library</span></span><br></pre></td></tr></table></figure><h3 id="ctest">ctest</h3><p>ctest 是 CMake 的测试工具，可以用于运行测试。可以通过 <code>add_test</code> 指令添加对应的测试。签名如下: <code>add_test(NAME &lt;test_name&gt; COMMAND &lt;executable&gt; [arg1 [arg2 ...]])</code></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>() <span class="comment"># enable testing</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> <span class="keyword">test</span>.cpp) <span class="comment"># add test target</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME example-<span class="keyword">test</span> <span class="keyword">COMMAND</span> <span class="keyword">test</span> config.yaml &gt; <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="keyword">test</span>.log) <span class="comment"># add test</span></span><br></pre></td></tr></table></figure><h3 id="常用变量">常用变量</h3><ul><li>CMAKE_SOURCE_DIR: 项目根目录</li><li>CMAKE_BINARY_DIR: 项目构建目录</li><li>CMAKE_CURRENT_SOURCE_DIR: 当前处理的 CMakeLists.txt 文件所在的目录</li><li>CMAKE_PREFIX_PATH: 查找库的路径</li><li>CMAKE_MODULE_PATH: 查找模块的路径</li><li>CMAKE_INCLUDE_PATH: 查找头文件的路径</li><li>CMAKE_LIBRARY_PATH: 查找库文件的路径</li><li>CMAKE_INSTALL_PREFIX: 安装目录</li><li>CMAKE_BUILD_TYPE: 构建类型，如 Debug、Release、RelWithDebInfo、MinSizeRel</li><li>CMAKE_C_COMPILER: C 编译器</li><li>CMAKE_CXX_COMPILER: C++ 编译器</li><li>CMAKE_C_FLAGS: C 编译选项</li><li>CMAKE_CXX_FLAGS: C++ 编译选项</li><li>CMAKE_EXE_LINKER_FLAGS: 可执行文件链接选项</li><li>CMAKE_LINKER_FLAGS: 链接选项</li></ul><h3 id="CMake-Cli">CMake Cli</h3><p>虽然 CMake 有提供 GUI 工具，但是大部分情况下还是使用命令行工具。CMake 的命令行工具是 cmake，可以通过 cmake --help 查看帮助信息。</p><p>常用命令行参数：</p><ul><li><code>cmake -B&lt;build-dir&gt;</code>: 指定构建目录</li><li><code>cmake &lt;source-dir&gt;</code>: 指定源代码目录</li><li><code>cmake --build &lt;build-dir&gt;</code>: 构建项目</li><li><code>cmake -D&lt;variable&gt;=&lt;value&gt;</code>: 设置变量</li><li><code>ctest -C &lt;build-dir&gt;</code>: 在指定的构建目录下运行测试</li></ul><h2 id="拓展">拓展</h2><ul><li><a href="https://www.foonathan.net/2016/03/cmake-install/">让 CMake install 支持 find_package</a></li><li><a href="https://github.com/microsoft/vcpkg">vcpkg</a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_precompile_headers.html">precompiled headers</a></li></ul><h2 id="废话">废话</h2><p>由于 CMake 语法过于复杂，实际使用时应多去官网查找用法。网址贴到<a href="https://cmake.org/documentation/">这里</a>，不过官网的文档查找效率低下，个人一般都是找大型 cmake 项目直接抄 CMakeLists.txt （</p><p><img src="Image_1728729096791.jpg" alt="😆"></p><!--CMake 语法是依托，历史遗留太多(支持 JAVA 没看懂)。但是由于其存在已久，大量的开源库都使用 CMake 作为构建工具,加上目前比较好用的 C/C++ 包管理区 `vcpkg` 也使用 CMake 作为构建工具，所以学习 CMake 是必要的。-->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构建系统发展历史&quot;&gt;构建系统发展历史&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;手工编译 (1950s - 1960s): 编程语言刚刚诞生，程序员需要手工编译程序，将源代码转换为机器码。&lt;/li&gt;
&lt;li&gt;批处理脚本 (1960s - 1970s)： 使用批处理脚本或 she</summary>
      
    
    
    
    <category term="Knowledge" scheme="http://blog.vollate.top/categories/Knowledge/"/>
    
    
    <category term="CMake" scheme="http://blog.vollate.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>配置自己的邮件服务器</title>
    <link href="http://blog.vollate.top/2024/09/26/deploy-self-mail-server/"/>
    <id>http://blog.vollate.top/2024/09/26/deploy-self-mail-server/</id>
    <published>2024-09-26T04:57:57.000Z</published>
    <updated>2024-09-26T04:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有事需要收发邮件，但是不想用自己的私人邮箱。正好<s>手上有个域名，就想着自己搭建一个邮件服务器</s>闲得慌，这里记录一下搭建过程。</p><p>选用的邮件服务器是 <a href="https://docker-mailserver.github.io/docker-mailserver/latest/">docker-mailserver</a>，可以方便的在容器内部署，配置也相对简便，更改 <code>docker-compose.yml</code> 文件即可。</p><h2 id="准备工作">准备工作</h2><h3 id="服务器">服务器</h3><p>首先需要一台服务器，然后装好 docker 和 docker-compose，我使用的是 Debian 12，安装过程不再赘述。</p><h3 id="域名解析">域名解析</h3><p>在你的 DNS 服务商处添加 MX 记录，指向你的服务器地址。我使用 Cloudflare 托管，添加的 MX 记录如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type: MX</span><br><span class="line">Name: @ // 代表根域名</span><br><span class="line">Content: mail.example.com // 你的邮件服务器地址，这里使用 mail.example.com 作为示例，你可以使用自己的二级域名</span><br><span class="line">Priority: 10 // 优先级，如果只有一个邮件服务器，可以随意设置</span><br><span class="line">Proxied: DNS only</span><br><span class="line">TTL: Auto</span><br></pre></td></tr></table></figure><p>完成后用 <code>dig</code> 命令检查 MX 记录是否生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig MX example.com</span><br></pre></td></tr></table></figure><h3 id="配置-SSL-证书">配置 SSL 证书</h3><p>docker-mailserver 默认使用 Let’s Encrypt 证书，所以需要配置好域名解析，确保能够访问到你的服务器。如果你没有在服务器上部署任何网址(80端口未占用) Let’s Encrypt 会自动验证域名，生成证书。</p><p>在服务器上，可以使用 <code>certbot</code> 工具生成证书，你可以查看<a href="https://certbot.eff.org/instructions">这个网站</a>来获得在你 WebServer 和发行版上的最佳实现。我的服务器使用的是 Nginx。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install certbot</span><br><span class="line"><span class="built_in">sudo</span> apt install </span><br><span class="line"><span class="built_in">sudo</span> certbot certonly --standalone -d mail.example.com -d example.com</span><br></pre></td></tr></table></figure><h3 id="部署-docker-mailserver">部署 docker-mailserver</h3><ul><li>首先创建一个目录，用于存放 docker-compose.yml 文件和其他配置文件。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mailserver</span><br><span class="line"><span class="built_in">cd</span> mailserver</span><br></pre></td></tr></table></figure><ul><li>然后将 docker-compose.yml 文件下载到当前目录。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/docker-mailserver/docker-mailserver/master/docker-compose.yml</span><br></pre></td></tr></table></figure><p>根据你的需求修改 <code>docker-compose.yml</code> 文件，我修改后的文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mailserver:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/mailserver/docker-mailserver:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">mail.example.com</span></span><br><span class="line">    <span class="attr">domainname:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mailserver</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;25:25&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;143:143&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;465:465&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;587:587&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;993:993&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./docker-data/dms/mail-data/:/var/mail/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./docker-data/dms/mail-state/:/var/mail-state/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./docker-data/dms/mail-logs/:/var/log/mail/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./docker-data/dms/config/:/tmp/docker-mailserver/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_SPAMASSASSIN=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_FAIL2BAN=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_OPENDKIM=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_OPENDMARC=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTFIX_MESSAGE_SIZE_LIMIT=102400000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DMS_DEBUG=0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSL_TYPE=letsencrypt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSL_DOMAIN=example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LETSENCRYPT_EMAIL=admin@example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSL_LTS=1</span>                     </span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">maildata:</span></span><br><span class="line">  <span class="attr">mailstate:</span></span><br><span class="line">  <span class="attr">maillogs:</span></span><br></pre></td></tr></table></figure><p>完成后，运行 <code>docker-compose up -d</code> 启动容器。第一次启动后，要在120秒内创建第一个用户，否则容器会自动关闭。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mailserver setup email add xxx@example.com password</span><br></pre></td></tr></table></figure><h3 id="开放端口">开放端口</h3><p>在服务器上开放以下端口：</p><ul><li>25: SMTP</li><li>143: IMAP</li><li>465: SMTPS</li><li>587: Submission</li><li>993: IMAPS</li></ul><p>我的服务器使用 iptables 防火墙，开放端口的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 25 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 143 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 465 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 587 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 993 -j ACCEPT</span><br></pre></td></tr></table></figure><p>要持久化这些规则，可以使用 <code>netfilter-persistent</code> 工具：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install iptables-persistent</span><br></pre></td></tr></table></figure><p>执行 <code>sudo netfilter-persistent save</code> 保存规则。</p><h2 id="进阶配置">进阶配置</h2><p>刚刚配好的邮件服务器给 gmail 发邮件时，会被标记为垃圾邮件，这是因为缺少 SPF、DKIM 和 DMARC 记录。我们需要配置这些记录。</p><h3 id="SPF">SPF</h3><p>SPF 是一种用于防范伪造邮件的技术，通过在 DNS 中添加 SPF 记录，可以指定哪些 IP 地址可以发送邮件。由于我们的邮件服务器只有一台，所以可以直接指定服务器的 IP 地址。在 Cloudflare 中添加 TXT 记录：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Type: TXT</span><br><span class="line">Name: @</span><br><span class="line">Content: v=spf1 mx -all</span><br><span class="line">TTL: Auto</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>v=spf1</code>：SPF 版本</li><li><code>mx</code>：允许 MX 记录指定的服务器发送邮件</li><li><code>-all</code>：拒绝所有其他服务器发送邮件</li></ul><h3 id="DKIM">DKIM</h3><p>DomainKeys Identified Mail (DKIM) 是一种用于验证邮件来源的技术，通过在 DNS 中添加 DKIM 记录，可以验证邮件的真实性。docker-mailserver 已经为我们内置并自动开启了 OpenDKIM，我们只需要生成 DKIM 密钥并提取公钥添加到 DNS 中。<a href="https://docker-mailserver.github.io/docker-mailserver/latest/config/best-practices/dkim_dmarc_spf/#dkim">官方文档</a>中有详细的步骤。</p><p>由于我们需要指定特定子域名，所以需要在依照文档中 <code>You may need to specify mail domains explicitly</code> 部分的步骤中添加 <code>-d mail.example.com</code> 参数，命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mailserver /bin/bash</span><br><span class="line">setup config dkim domain <span class="string">&#x27;mail.example.com&#x27;</span></span><br><span class="line">setup config dkim domain mail.example.com</span><br></pre></td></tr></table></figure><p>然后，在刚刚打开的 shell 中查看公钥：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /tmp/docker-mailserver/opendkim/keys/mail.example.com/mail.txt</span><br></pre></td></tr></table></figure><p>将输出的内容添加到 DNS 中，具体参考<a href="https://docker-mailserver.github.io/docker-mailserver/latest/config/best-practices/dkim_dmarc_spf/#dkim-dns">这块</a>：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Type: TXT</span><br><span class="line">Name: mail._domainkey</span><br><span class="line">Content: v=DKIM1; k=rsa; p=xxxxxx</span><br><span class="line">TTL: Auto</span><br></pre></td></tr></table></figure><h3 id="DMARC">DMARC</h3><p>Domain-based Message Authentication, Reporting and Conformance (DMARC) 是一种用于验证邮件来源的技术，通过在 DNS 中添加 DMARC 记录，可以指定邮件的处理方式。docker-mailserver 已经为我们内置并自动开启了 OpenDMARC，我们只需要添加 DMARC 记录。在 Cloudflare 中添加 TXT 记录：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Type: TXT</span><br><span class="line">Name: _dmarc</span><br><span class="line">Content: v=DMARC1; p=none; rua=mailto:admin@example.com</span><br><span class="line">TTL: Auto</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>v=DMARC1</code>：DMARC 版本</li><li><code>p=none</code>：指定邮件的处理方式，<code>none</code> 表示不做任何处理</li><li><code>rua=mailto:</code>：指定报告的接收邮箱</li><li><code>ruf=mailto:</code>：指定失败报告的接收邮箱</li><li><code>sp=none</code>：指定子域名的处理方式</li><li><code>adkim=s</code>：指定 DKIM 的验证方式</li><li><code>aspf=r</code>：指定 SPF 的验证方式</li><li><code>pct=100</code>：指定报告的百分比</li><li><code>rf=afrf</code>：指定报告的格式</li></ul><h3 id="rDNS">rDNS</h3><p>反向 DNS (rDNS) 是一种用于验证 IP 地址的技术，通过在 DNS 中添加 PTR 记录，可以验证 IP 地址的真实性。这需要联系服务器提供商来配置。</p><h2 id="验证邮件服务器正常工作">验证邮件服务器正常工作</h2><p>我们可以使用 <a href="https://dkimvalidator.com/">dkimvalidator.com</a> 来验证 DKIM 和 DMARC 记录是否生效，使用 <a href="https://www.mail-tester.com/">www.mail-tester.com</a> 来验证邮件是否被标记为垃圾邮件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近有事需要收发邮件，但是不想用自己的私人邮箱。正好&lt;s&gt;手上有个域名，就想着自己搭建一个邮件服务器&lt;/s&gt;闲得慌，这里记录一下搭建过程。&lt;/p&gt;
&lt;p&gt;选用的邮件服务器是 &lt;a href=&quot;https://docker-mailserver.github.io/docke</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Server" scheme="http://blog.vollate.top/tags/Server/"/>
    
    <category term="Emali" scheme="http://blog.vollate.top/tags/Emali/"/>
    
  </entry>
  
  <entry>
    <title>使用 pass 管理密码</title>
    <link href="http://blog.vollate.top/2024/08/10/pass-sync/"/>
    <id>http://blog.vollate.top/2024/08/10/pass-sync/</id>
    <published>2024-08-10T11:48:05.000Z</published>
    <updated>2024-12-13T19:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.passwordstore.org/">zx2c4 pass</a> 是一个 unix 下的密码管理工具，使用 gpg 加密密码，配合 git 可以方便的实现密码同步，来彻底摆脱 browser 和其他各式各样非自由密码管理工具。<br>下面介绍 pass 的配置，密码迁移，以及各个客户端的使用方法。</p><h2 id="配置">配置</h2><h3 id="安装-pass">安装 pass</h3><p>UNIX like 系统直接使用包管理器安装即可，我的系统是 Arch, 使用 pacman 安装:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已有 gpg 和 git 的忽略这步</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S gnupg git</span><br><span class="line"></span><br><span class="line"><span class="comment"># pass 本体为 cli 工具，可以配合 qtpass 来使用</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S pass qtpass</span><br></pre></td></tr></table></figure><p>如果是windows，可以尝试以下几个平替:</p><ul><li><a href="https://github.com/gopasspw/gopass">gopass</a>: go 实现的 pass，支持较全</li><li><a href="https://github.com/timvisee/prs">prs</a>: rust 实现的 pass，但不支持 extension</li><li><a href="https://github.com/geluk/pass-winmenu">pass-winmenu</a>: 可以实现 pass 的基本功能，但为 GUI 应用</li><li><a href="https://github.com/bfrascher/passpy">passpy</a>: python 实现的 pass，功能补全且年久失修</li><li><a href="https://github.com/mbos/Pass4Win">pass4win</a>: 年久失修且已经 archiving ，不建议使用</li></ul><h3 id="初始化-pass">初始化 pass</h3><p>在使用 pass 之前，先生成 gpg 密钥对。已有 gpg 密钥对可以跳过这一步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gpg --full-generate-key <span class="comment"># 然后根据提示输入对应信息和你要设置的密码</span></span><br><span class="line"></span><br><span class="line">gpg --list-secret-keys --keyid-format LONG </span><br><span class="line"><span class="comment"># 列出密钥的 gpg-id, 大概的输出长这样:</span></span><br><span class="line"><span class="comment"># /home/foo/.gnupg/pubring.kbx</span></span><br><span class="line"><span class="comment"># ----------------------------------</span></span><br><span class="line"><span class="comment"># sec   ed25519/xxx 20xx-xx-xx [SC] [expires: 20xx-xx-xx]</span></span><br><span class="line"><span class="comment">#       &lt;gpg-id&gt;</span></span><br><span class="line"><span class="comment"># uid                 [ unknown] vollate &lt;uint44t@gmail.com&gt;</span></span><br><span class="line"><span class="comment"># ssb   cv25519/xxxxxxxxxxxxxxxx 20xx-xx-xx [E] [expires: 20xx-xx-xx]</span></span><br><span class="line"></span><br><span class="line">pass init &lt;gpg-id&gt; <span class="comment"># 使用 gpg-id 初始化 pass</span></span><br></pre></td></tr></table></figure><p>经过初始化，会生成 <code>~/.password-store</code> 目录。目录下会生成一个 <code>.gpg-id</code> 文件，存放了用来加密密码的 gpg key 的 id。</p><p>如果你想要导入或导出 gpg key,使用下面的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export</span></span><br><span class="line">gpg --export-secret-keys -a &lt;gpg-id&gt; &gt; private.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># import</span></span><br><span class="line">gpg --import private.key</span><br></pre></td></tr></table></figure><p>注意，使用 <code>--export-secret-keys</code> 导出私钥，否则行为为导出公钥。</p><h3 id="同步密码">同步密码</h3><p>使用 git 来同步密码，这里使用 github 作为远程仓库。推荐使用 ssh-key 进行认证，因为github很早就停止了使用密码认证。</p><p>首先创建你的 private repo，不用添加 gitignore 或 readme，然后初始化你的 .password-store 并 ref 到远程仓库。<s>或者你可以跟我一样偷懒 clone 下来然后 把 .git 扔进 .password-store 里。</s> 之后就可以使用git 来管理密码了。</p><h2 id="从浏览器迁移">从浏览器迁移</h2><p>firefox,chrome,edge都支持导出密码为 csv 文件，首先导出密码到 csv 文件，然后安装 <a href="https://github.com/roddhjav/pass-import">pass-import</a>。 使用下面的命令导入密码:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pass import &lt;csv-file&gt;</span><br></pre></td></tr></table></figure><p>更多用法见 <a href="https://github.com/roddhjav/pass-import?tab=readme-ov-file#usage">useage</a></p><p>导出完后记得清空浏览器保存的密码。如果开启了云同步，需要在 history 中删除密码后同步到云端。</p><ul><li>Chome 直接历史记录清除密码后会自动同步</li><li>Edge 需要在历史记录中删除密码后手动强制同步<img src="fucking-mc.png" alt="fucking microsoft"></li><li>firefox 在 password manager 右上角可以直接删除所有密码。</li></ul><h2 id="客户端">客户端</h2><p>下面推荐几个个人使用的客户端:</p><ul><li><a href="https://qtpass.org/">qtpass</a>: pass 的 qt 客户端，支持图形化操作和一定 extension</li><li><a href="https://codeberg.org/PassFF/passff">passff</a>: firefox 插件，可以在浏览器中使用 pass 来填充密码，基本可以做到完全替代浏览器自带的密码管理器(<s>但是 windows 上支持稀烂</s> 修好了，详情见下)</li><li><a href="https://github.com/android-password-store/Android-Password-Store">Android-Password-Store</a>: Android 客户端，支持加密解密和 git 同步，但是自动填充稀烂</li></ul><h2 id="passff-on-windows">passff on windows</h2><p>首先安装 passff-host， 按照<a href="https://github.com/passff/passff-host">官网</a>说明下载 <code>.bat</code> 文件，然后运行,命令行参数选择你要安装的浏览器，我这里是 firefox。执行完成后会下载几个文件，位置自己翻脚本里面，和你安装的浏览器有关（或者everything直接搜 <code>passff.py</code>，对应文件夹就是）。安装 <code>gopass</code>,推荐使用 <code>scoop</code> 安装。<br>然后对 <code>passff.py</code> 开头部分进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">######################## Begin preferences section ############################</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line">COMMAND = <span class="string">&quot;gopass&quot;</span> <span class="comment"># Rename this to your target pass-like executable</span></span><br><span class="line">COMMAND_ARGS = []</span><br><span class="line">COMMAND_ENV = &#123;</span><br><span class="line">    <span class="string">&quot;TREE_CHARSET&quot;</span>: <span class="string">&quot;ISO-8859-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PATH&quot;</span>: os.environ.get(<span class="string">&quot;PATH&quot;</span>), <span class="comment"># Fix stupid path</span></span><br><span class="line">&#125;</span><br><span class="line">CHARSET = <span class="string">&quot;UTF-8&quot;</span></span><br></pre></td></tr></table></figure><p>然后就可以在 windows 上的浏览器中使用 pass 了。</p><h2 id="扩展">扩展</h2><p>pass 支持 extension，具体参考<a href="https://github.com/tijn/awesome-password-store">这个合集</a>，找自己需要的用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.passwordstore.org/&quot;&gt;zx2c4 pass&lt;/a&gt; 是一个 unix 下的密码管理工具，使用 gpg 加密密码，配合 git 可以方便的实现密码同步，来彻底摆脱 browser 和其他各式各样非自由密码管理工具。&lt;</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Password" scheme="http://blog.vollate.top/tags/Password/"/>
    
  </entry>
  
  <entry>
    <title>Google GN CheatSheet</title>
    <link href="http://blog.vollate.top/2024/07/14/google-gn/"/>
    <id>http://blog.vollate.top/2024/07/14/google-gn/</id>
    <published>2024-07-14T06:44:21.000Z</published>
    <updated>2024-07-14T14:37:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法">基础语法</h2><ol><li><p>目标(Target)</p><ul><li>executable：定义一个可执行目标</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">executable(&quot;my_app&quot;) &#123;</span><br><span class="line">    sources = [ &quot;main.cc&quot;  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>shared_library：定义一个共享库目标</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared_library(&quot;my_shared_lib&quot;) &#123;</span><br><span class="line">    sources = [ &quot;shared_lib.cc&quot;  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>static_library：定义一个静态库目标</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static_library(&quot;my_static_lib&quot;) &#123;</span><br><span class="line">    sources = [ &quot;static_lib.cc&quot;  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>source_set：定义一组源文件，通常用于中间构建</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source_set(&quot;my_sources&quot;) &#123;</span><br><span class="line">    sources = [ &quot;file1.cc&quot;, &quot;file2.cc&quot;  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量</p><ul><li>sources：定义要包含在目标中的源文件列表</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sources = [ &quot;main.cc&quot;, &quot;util.cc&quot;  ]</span><br></pre></td></tr></table></figure><ul><li>deps：定义目标的依赖项列表</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deps = [ &quot;//:my_static_lib&quot;  ]</span><br></pre></td></tr></table></figure><ul><li>public_deps：类似于 deps，但会将依赖项公开给依赖此目标的其他目标</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public_deps = [ &quot;//:my_shared_lib&quot;  ]</span><br></pre></td></tr></table></figure></li><li><p>函数</p><ul><li>import：导入其他 GN 文件中的内容，只能在文件的顶部使用，用于配置变量和默认值</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import(&quot;//build/config.gni&quot;)</span><br></pre></td></tr></table></figure><ul><li>set_defaults：设置默认值，通常用于设置全局配置</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_defaults(&quot;executable&quot;) &#123;</span><br><span class="line">  output_name = &quot;default_executable&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>template：定义模板，便于复用构建规则(就是模板函数)</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># definition</span><br><span class="line">template(&quot;foo&quot;) &#123;</span><br><span class="line">    assert(defined(invoker.var1), &quot;var1 must be defined&quot;)</span><br><span class="line">    print(invoker.var1)</span><br><span class="line">    print(invoker.var2)</span><br><span class="line">    # something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># useage</span><br><span class="line">foo(&quot;useless&quot;)&#123;</span><br><span class="line">    var1 = &quot;foo&quot;</span><br><span class="line">    var2 = &quot;bar&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p><ul><li>config：定义一组编译或链接选项，可以在多个目标中复用</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config(&quot;default_cflags&quot;) &#123;</span><br><span class="line">    cflags = [ &quot;-Wall&quot;, &quot;-Werror&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工具链</p><ul><li>toolchain：定义一个工具链，用于指定编译和链接的工具及其选项</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toolchain(&quot;my_toolchain&quot;) &#123;</span><br><span class="line">    tool(&quot;cc&quot;) &#123;</span><br><span class="line">        command = &quot;gcc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    tool(&quot;cxx&quot;) &#123;</span><br><span class="line">        command = &quot;g++&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    tool(&quot;link&quot;) &#123;</span><br><span class="line">        command = &quot;g++&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>过滤器(Filter)</p><ul><li>sources_assignment_filter：用于过滤 sources 列表中的文件</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sources_assignment_filter = [ &quot;*.cc&quot;, &quot;*.h&quot;  ]</span><br></pre></td></tr></table></figure></li><li><p>分组</p><ul><li>group：定义一个构建目标的分组</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group(&quot;all&quot;) &#123;</span><br><span class="line">      deps = [ &quot;:target1&quot;, &quot;:target2&quot;  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>外部脚本执行</p><ul><li>exec_script：运行外部脚本，并将结果导入 GN 配置中</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = exec_script(&quot;find_sources.py&quot;, [], &quot;string_list&quot;)</span><br><span class="line">sources = result</span><br></pre></td></tr></table></figure></li><li><p>控制流(control flow)</p><ul><li>if：条件语句，用于在 GN 文件中进行条件构建</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (is_win) &#123;</span><br><span class="line">    # win config</span><br><span class="line">&#125; else if (is_linux)&#123;</span><br><span class="line">    # linux config</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    # other config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>foreach:编译列表</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var_list=[</span><br><span class="line">    &quot;a&quot;,</span><br><span class="line">    &quot;b&quot;,</span><br><span class="line">    &quot;c&quot;</span><br><span class="line">]</span><br><span class="line">foreach(var, var_list) &#123;</span><br><span class="line">    rubbish += var</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用域</p><ul><li>set_defaults：设置默认值，通常用于设置全局配置</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_defaults(&quot;executable&quot;) &#123;</span><br><span class="line">    output_name = &quot;default_executable&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>scope：定义一个作用域，可以在 GN 文件中组织和管理变量和目标</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scope(&quot;my_scope&quot;) &#123;</span><br><span class="line">    sources = [ &quot;file1.cc&quot;, &quot;file2.cc&quot;  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成过程">生成过程</h2><p>和 CMake 类似，GN从根目录的 <code>BUILD.gn</code> 开始解析，通过 dependence 确定依赖子目录，然后在各个依赖的子目录中寻找 <code>BUILD.gn</code> 来构建依赖。解析文件的部分依赖脚本语言而不是 CMake 那样可以直接调用内置函数，有更高的灵活性，但是也更复杂。</p><h2 id="常用命令-参数">常用命令/参数</h2><ul><li><code>gn gen out/Default --args='...'</code>: 在 out/Default 目录生成 ninja 构建文件</li><li><code>gn desc out/Default //some_path:target --$&#123;additional&#125;</code>: 显示当前生成项目目录中某个 target 的详细信息<ul><li><code>--tree</code>: 显示生成 target 过程所有依赖调用顺序和参数</li><li><code>--blame</code>: 显示生成 target 过程的编译参数中每个参数的来源</li></ul></li><li><code>gn check out/Default</code>: 检查当前项目的配置是否正确</li><li><code>gn format</code>: 格式化所有 <a href="http://BUILD.gn">BUILD.gn</a> 文件</li><li><code>gn gen --ide=$&#123;x&#125; out/Default</code> 生成 IDE 项目文件<ul><li><code>--ide=json</code> 生成 JSON 格式的 IDE 项目文件,用于 clangd 等</li><li><code>--ide=vs</code> 生成 Visual Studio 项目文件(只支持x64 win32 两种target plateform)</li><li><code>--ide=xcode</code> 生成 Xcode 项目文件</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础语法&quot;&gt;基础语法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目标(Target)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;executable：定义一个可执行目标&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LLDB 在 Docker 中功能异常</title>
    <link href="http://blog.vollate.top/2024/06/26/docker-lldb-error/"/>
    <id>http://blog.vollate.top/2024/06/26/docker-lldb-error/</id>
    <published>2024-06-26T16:36:35.000Z</published>
    <updated>2024-07-01T15:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记-寄-录">记(寄)录</h2><p>写 15445 的时候发现 clang-14 以上编译 fmt 会报错（arch 包太新了导致的），因此在 debian12 的 docker 中挂载 host 文件夹开发。用 lldb debug 时在出现 exception 或 signal后 lldb 会报错 <code>A packet returned an error 8</code> 并退出进程，导致无法 backtrace，但是 gdb 没事。<br>原因是因为 lldb debug 用的 syscall ptrace 在 docker 中被限制了，解决方法是在 <code>docker run</code> 时加上 <code>--cap-add=SYS_PTRACE --security-opt seccomp=unconfined</code> 参数。<br><a href="https://stackoverflow.com/questions/69291157/lldb-producing-a-packet-returned-error-8-when-i-run-my-program">Problem on stack overflow</a></p><h2 id="Docker-小知识">Docker 小知识</h2><ul><li>Linux capabilities: Docker 关于 Linux capabilities 的<a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">章节</a>。这个是用来限制容器权限的，可以看到默认情况下 &quot;SYS_PTRACE Trace arbitrary processes using ptrace(2).&quot;是被禁用的，然后 lldb 就寄了（</li><li>Secure computing mode(Seccomp): 这是 Linux 内核的一个 feature,用于控制计算时的行为安全。Docker 默认的 profile 禁用了大约 44 个 syscall, ptrace 位列其中。通过 <code>--security-opt seccomp=unconfined</code> 来关闭这个 profile（图省事的不安全做法），正确的是改默认 profile 来自定义一个profile。然而我懒，就这样了。</li></ul><h2 id="ptrace-怎么不安全了">ptrace 怎么不安全了</h2><p><strong>Docker 官方文档</strong>:</p><ul><li>Blocked in Linux kernel versions before 4.8 to avoid seccomp bypass.</li><li>Tracing/profiling arbitrary processes is already blocked by dropping CAP_SYS_PTRACE, because it could leak a lot of information on the host.</li></ul><p>上 NVD 搜了一圈，好多文档都写的禁止使用 ptrace, debugger 和 strace（used to trace syscal)，但是没说为啥。cgroup 和 namespace 不是已经隔离了吗，等哪天有空查到再研究下。</p><!--TODO--><h2 id="为什么-GDB-没事">为什么 GDB 没事</h2><p>TODO: 找了半天资料没找到，gdb internals 偏偏这一章是咕咕的，先洗洗睡了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记-寄-录&quot;&gt;记(寄)录&lt;/h2&gt;
&lt;p&gt;写 15445 的时候发现 clang-14 以上编译 fmt 会报错（arch 包太新了导致的），因此在 debian12 的 docker 中挂载 host 文件夹开发。用 lldb debug 时在出现 except</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Docker" scheme="http://blog.vollate.top/tags/Docker/"/>
    
    <category term="LLDB" scheme="http://blog.vollate.top/tags/LLDB/"/>
    
  </entry>
  
  <entry>
    <title>gRPC &amp; Protobuf 学习</title>
    <link href="http://blog.vollate.top/2024/05/10/protobuf-and-grpc/"/>
    <id>http://blog.vollate.top/2024/05/10/protobuf-and-grpc/</id>
    <published>2024-05-10T10:42:59.000Z</published>
    <updated>2024-06-14T15:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读须知">阅读须知</h2><p>本文仅供学习参考，笔者的 protobuf 版本为 3.21.12.0，不保证其他版本的兼容性。</p><h2 id="proto-file">proto file</h2><p><code>.proto</code> 格式文件可以被 <a href="https://github.com/protocolbuffers/protobuf">protobuf(protocol buffer)</a> 解析，用于定义服务和消息格式的语言。通过 <code>protobuf</code> 的 <code>protoc</code> 可以生成符合同一通讯协议的对应的代码框架，以此实现跨语言 rpc 通讯。</p><p>废话不多说，直接上例子</p><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;<span class="comment">// proto file version</span></span><br><span class="line"><span class="keyword">package</span> package_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define the service</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">ChatService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> PublishRoom(PublishRoomRequest) <span class="keyword">returns</span> (PublishRoomReply)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetRoomPeers(GetRoomPeersRequest) <span class="keyword">returns</span> (GetRoomPeersReply)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define the status code(enum)</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">StatusCode</span>&#123;</span><br><span class="line">    OK = <span class="number">0</span>;</span><br><span class="line">    ERROR = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define the request and reply message</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PublishRoomRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> password = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">oneof</span> contact &#123;<span class="comment">// like union in c/c++</span></span><br><span class="line">        <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">        <span class="type">string</span> phone = <span class="number">4</span>;</span><br><span class="line">        <span class="type">int64</span> id = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PublishRoomReply</span> &#123;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetRoomPeersRequest</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> password = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> id   = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetRoomPeersReply</span>&#123;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> peers = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们大概知道了如何编写一个 <code>.proto</code> 文件，接下来我们详细讲解细节</p><h3 id="语法">语法</h3><p>首先附上<a href="https://protobuf.dev/programming-guides/"><strong>官方文档</strong></a></p><p>proto file 的语法分为两个版本，分别是 <code>proto2</code> 和 <code>proto3</code>，两个版语法本非常相似，但<code>proto3</code> 取消了 <code>require/optional</code> field，因此不建议给自己找事跨版本通讯。本文仅介绍 <code>proto3</code> 的语法。</p><ul><li>在 <code>.proto</code> 文件的开头，我们需要声明使用的版本 <code>syntax = &quot;proto$&#123;x&#125;&quot;;</code>，<code>$&#123;x&#125;</code> 为版本号，一定要在开头声明，否则默认会使用 <code>proto2</code> 的语法。</li><li>接下来我们需要声明包名 <code>package package_name;</code>，包名用于区分不同的服务，避免命名冲突，实际编码中会转换成各个语言的包名或名称空间，如 C++ 会转换成 <code>namespace package_name;</code>， Rust 会转换成 <code>mod package_name;</code></li><li><code>service</code> 用于定义服务，服务中包含多个 <code>rpc</code> 方法，<code>rpc</code> 方法包含请求和响应消息，具体会在后面讲解</li><li>之后是各类复合类型定义，如 <code>enum</code>、<code>message</code> 等，该模块和 service 定义没有顺序要求，只要 <code>service</code> 中使用的复合类型在本文件中定义即可</li></ul><h4 id="Scalar-Value-Types">Scalar Value Types</h4><p>gRPC 中共用如下几种基础类型，在编译时会转换成对应语言的基础类型:</p><ul><li><p>变长编码（Varint）：</p><ul><li>int32（有符号整数）</li><li>int64（有符号整数）</li><li>uint32（无符号整数）</li><li>uint64（无符号整数）</li><li>sint32（有符号整数，使用 ZigZag 编码）</li><li>sint64（有符号整数，使用 ZigZag 编码）</li><li>bool（布尔值，存储为 0 或 1）</li><li>enum（枚举，通常作为 Varint 编码的整数）</li></ul></li><li><p>固定长度编码：</p><ul><li>fixed32（32 位有符号整数，固定 4 字节）</li><li>fixed64（64 位有符号整数，固定 8 字节）</li><li>sfixed32（32 位有符号整数，固定 4 字节）</li><li>sfixed64（64 位有符号整数，固定 8 字节）</li><li>float（32 位浮点数，固定 4 字节）</li><li>double（64 位浮点数，固定 8 字节）</li></ul></li><li><p>长度前缀编码：</p><ul><li>string（字符串）</li><li>bytes（二进制数据）</li><li>message（嵌套消息）</li></ul></li></ul><p>这种多种编码方式允许 Protocol Buffers 以高效和紧凑的方式进行序列化。</p><details>  <summary>各语言具体转换，点我展开</summary>  <table style="width:100%"><tbody><tr><th>.proto Type</th><th>Notes</th><th>C++ Type</th><th>Java/Kotlin Type<sup>[1]</sup></th><th>Python Type<sup>[3]</sup></th><th>Go Type</th><th>Ruby Type</th><th>C# Type</th><th>PHP Type</th><th>Dart Type</th></tr><tr><td>double</td><td></td><td>double</td><td>double</td><td>float</td><td>float64</td><td>Float</td><td>double</td><td>float</td><td>double</td></tr><tr><td>float</td><td></td><td>float</td><td>float</td><td>float</td><td>float32</td><td>Float</td><td>float</td><td>float</td><td>double</td></tr><tr><td>int32</td><td>Uses variable-length encoding. Inefficient for encoding negativenumbers – if your field is likely to have negative values, use sint32instead.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum or Bignum (as required)</td><td>int</td><td>integer</td><td>int</td></tr><tr><td>int64</td><td>Uses variable-length encoding. Inefficient for encoding negativenumbers – if your field is likely to have negative values, use sint64instead.</td><td>int64</td><td>long</td><td>int/long<sup>[4]</sup></td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string<sup>[6]</sup></td><td>Int64</td></tr><tr><td>uint32</td><td>Uses variable-length encoding.</td><td>uint32</td><td>int<sup>[2]</sup></td><td>int/long<sup>[4]</sup></td><td>uint32</td><td>Fixnum or Bignum (as required)</td><td>uint</td><td>integer</td><td>int</td></tr><tr><td>uint64</td><td>Uses variable-length encoding.</td><td>uint64</td><td>long<sup>[2]</sup></td><td>int/long<sup>[4]</sup></td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string<sup>[6]</sup></td><td>Int64</td></tr><tr><td>sint32</td><td>Uses variable-length encoding. Signed int value. These moreefficiently encode negative numbers than regular int32s.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum or Bignum (as required)</td><td>int</td><td>integer</td><td>int</td></tr><tr><td>sint64</td><td>Uses variable-length encoding. Signed int value. These moreefficiently encode negative numbers than regular int64s.</td><td>int64</td><td>long</td><td>int/long<sup>[4]</sup></td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string<sup>[6]</sup></td><td>Int64</td></tr><tr><td>fixed32</td><td>Always four bytes. More efficient than uint32 if values are oftengreater than 2<sup>28</sup>.</td><td>uint32</td><td>int<sup>[2]</sup></td><td>int/long<sup>[4]</sup></td><td>uint32</td><td>Fixnum or Bignum (as required)</td><td>uint</td><td>integer</td><td>int</td></tr><tr><td>fixed64</td><td>Always eight bytes. More efficient than uint64 if values are oftengreater than 2<sup>56</sup>.</td><td>uint64</td><td>long<sup>[2]</sup></td><td>int/long<sup>[4]</sup></td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string<sup>[6]</sup></td><td>Int64</td></tr><tr><td>sfixed32</td><td>Always four bytes.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum or Bignum (as required)</td><td>int</td><td>integer</td><td>int</td></tr><tr><td>sfixed64</td><td>Always eight bytes.</td><td>int64</td><td>long</td><td>int/long<sup>[4]</sup></td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string<sup>[6]</sup></td><td>Int64</td></tr><tr><td>bool</td><td></td><td>bool</td><td>boolean</td><td>bool</td><td>bool</td><td>TrueClass/FalseClass</td><td>bool</td><td>boolean</td><td>bool</td></tr><tr><td>string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannotbe longer than 2<sup>32</sup>.</td><td>string</td><td>String</td><td>str/unicode<sup>[5]</sup></td><td>string</td><td>String (UTF-8)</td><td>string</td><td>string</td><td>String</td></tr><tr><td>bytes</td><td>May contain any arbitrary sequence of bytes no longer than 2<sup>32</sup>.</td><td>string</td><td>ByteString</td><td>str (Python 2)<br>bytes (Python 3)</td><td>[]byte</td><td>String (ASCII-8BIT)</td><td>ByteString</td><td>string</td><td>List<int></int></td></tr></tbody></table></details><p>这是官网的表格照抄结果，请以官方文档为准以避免任何时效性问题。<a href="https://protobuf.dev/programming-guides/proto3/#scalar">官方文档链接</a></p><h4 id="Enumerations">Enumerations</h4><h4 id="Union-Variant">Union(Variant)</h4><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">PublishRoomRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> password = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">oneof</span> contact &#123;<span class="comment">// like union in c/c++</span></span><br><span class="line">        <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">        <span class="type">string</span> phone = <span class="number">4</span>;</span><br><span class="line">        <span class="type">int64</span> id = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Message">Message</h4><p>就是 Struct, 用于定义复杂的数据结构，可以嵌套定义，可以包含 <code>enum</code>、<code>message</code>、<code>oneof</code> 等<br>可以用 <code>repeated</code> 关键字定义数组</p><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Service-定义">Service 定义</h4><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">ChatService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> PublishRoom(PublishRoomRequest) <span class="keyword">returns</span> (PublishRoomReply)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetRoomPeers(GetRoomPeersRequest) <span class="keyword">returns</span> (stream GetRoomPeersReply)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetRoomsPeers(stream GetRoomPeersRequest) <span class="keyword">returns</span> (stream GetRoomPeersReply)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stream</code> use to specify a stream message, which means the server or client can send or receive multiple messages in one rpc call.</p><h2 id="grpc-一些教程">grpc 一些教程</h2><ul><li><a href="https://grpc.io/">官网</a>找自己要用的语言去看</li><li><a href="https://github.com/mengbin92/protobuf/blob/master/docs/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97(proto3).md">找的某个 blog</a></li></ul><h2 id="有趣的东西">有趣的东西</h2><p>语法说实话没啥看的，用的时候再查，但是编码挺好玩的。<a href="https://protobuf.dev/programming-guides/encoding/">官方介绍</a></p><h3 id="可变长度编码">可变长度编码</h3><p>将原数按小端序编码，然后分为 7 bits 一组，每 byte 的 MSB（最高位）表示是否还有后续(0表示无，1表示有)。由于按小端序而不是传统的大端序（网络字节序），可以节省数字较小时高位的存储空间。当然对于大数需要最多10 bytes来传输，因此在已知数据都较大时应直接使用定长编码。</p><h3 id="ZigZag-编码">ZigZag 编码</h3><p>为了解决负数而生。因为负数的标准表示方式是 MSB 设 1 的 2 补码，会导致大负数的可变长度编码远远长于同绝对值的正数。如果是期望为 0 的高斯分布，用上面的变长编码会产生很大的消耗。ZigZag 编码将负数映射到正数，使得绝对值较小的负数的编码长度接近于正数。</p><ul><li>编码: <code>n &lt;&lt; 1 ^ n &gt;&gt; len</code>, 其中 <code>len</code> 为 n 的位数</li><li>解码: <code>(n &gt;&gt; 1) ^ -(n &amp; 1)</code></li></ul><blockquote><p>本质: 只用正数表示绝对值大小，符号位从 MSB 换为 LSB, 这样让上面的变长编码关于绝对值大小的优势得以保留。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阅读须知&quot;&gt;阅读须知&lt;/h2&gt;
&lt;p&gt;本文仅供学习参考，笔者的 protobuf 版本为 3.21.12.0，不保证其他版本的兼容性。&lt;/p&gt;
&lt;h2 id=&quot;proto-file&quot;&gt;proto file&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.proto&lt;/code&gt; 格</summary>
      
    
    
    
    
    <category term="Notes" scheme="http://blog.vollate.top/tags/Notes/"/>
    
    <category term="RPC" scheme="http://blog.vollate.top/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 下 Firefox 无法正确显示 emoji</title>
    <link href="http://blog.vollate.top/2024/02/20/missing-emoji/"/>
    <id>http://blog.vollate.top/2024/02/20/missing-emoji/</id>
    <published>2024-02-20T16:11:59.000Z</published>
    <updated>2024-12-02T12:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>firefox 无法显示任何 emoji，但 chrome，edge 均显示正常</p><h2 id="折腾过程">折腾过程</h2><p>首先怀疑是 firefox 什么地方配置炸了。搜了几篇提问，解决方案都无效，包括 Arch wiki 上的<a href="https://wiki.archlinuxcn.org/wiki/Firefox#%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98">这个</a>。<br>然后我开了下自己另一台电脑上的 Arch 发现显示正常，于是推断可能是缺字体。具体是什么不清楚，但是包名中大概带 “emoji”。搜了半天没找到个能用的解决方案，noto-font-emoji 装了也没用。最后不抱希望搜了下<a href="https://archlinux.org/packages/">package</a>，原以为会出现一堆带 emoji 的，结果就十几个。看了看，觉得缺少 “unicode-emoji” 的可能性最高，装了，好了。<br>然后发现 vim 中的 warning 字体突然变成 unicode 里面那个黄色 warning（丑），于是又把包卸了。重启后发现 firefox 中 emoji 正常显示，大概是本地哪个配置文件炸了一开始才显示不了。</p><h2 id="总结">总结</h2><p>人生 -1h<br>强迫症满足++<br>折腾 Linux 经验++</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;firefox 无法显示任何 emoji，但 chrome，edge 均显示正常&lt;/p&gt;
&lt;h2 id=&quot;折腾过程&quot;&gt;折腾过程&lt;/h2&gt;
&lt;p&gt;首先怀疑是 firefox 什么地方配置炸了。搜了几篇提问，解决方案都无效，包括 </summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Linux" scheme="http://blog.vollate.top/tags/Linux/"/>
    
    <category term="KDE Plasma" scheme="http://blog.vollate.top/tags/KDE-Plasma/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下系统代理配置</title>
    <link href="http://blog.vollate.top/2024/01/09/linux-desktop-system-proxy/"/>
    <id>http://blog.vollate.top/2024/01/09/linux-desktop-system-proxy/</id>
    <published>2024-01-09T15:57:33.000Z</published>
    <updated>2024-05-10T18:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>配置 firefox 系统代理时出现了一些问题，然后查了下 Linux 桌面系统代理的原理，记录一下</p><p>系统信息:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OS: Arch Linux x86_64 </span><br><span class="line">Kernel: 6.6.10-arch1-1 </span><br><span class="line">Packages: 1369 (pacman) </span><br><span class="line">Shell: zsh 5.9 </span><br><span class="line">DE: Plasma 5.27.10 </span><br><span class="line">WM: KWin </span><br><span class="line">Theme: [Plasma], Canta-dark [GTK2/3] </span><br><span class="line">Icons: Tela-circle-manjaro-dark [Plasma], Tela-circle-manjaro-dark [GTK2/3] </span><br></pre></td></tr></table></figure><p>使用 <code>clash-verge</code> 进行代理，然后 system-proxy 设置为 manual 后 edge 和 chrome 能正常识别。但是 firefox 死活不行，上网查了不支持代理的问题是11年前的。 无奈开始怀疑是 firefox 不支持 KDE 桌面环境的系统代理设置。</p><p><img src="2024-01-10_01-00.png" alt="setting"></p><h2 id="KDE-系统代理配置">KDE 系统代理配置</h2><p>如上图，配置好后，系统代理的信息可以在 <code>~/.config/kioslaverc</code> 中找到<br><img src="2024-01-10_01-04.png" alt="rc file"></p><h2 id="GNOME-系统代理配置">GNOME 系统代理配置</h2><p>GNOME 桌面同样可以通过 GUI 配置系统代理，具体不展示了因为没 GNOME 桌面(<s>全用Arch导致的</s>。GNOME 下桌面应用可以通过 <code>gsettings</code> 来获取对应的 key 值，如 <code>gsettings get org.gnome.system.proxy mode</code> 可以获取现在的系统代理模式。</p><h2 id="解决问题">解决问题</h2><p>发现 <code>clash-verge</code> 内置的系统代理配置的是 <code>gsettings</code> 的选项，而且 firefox 只认 GNOME 的系统代理配置(Mozilla 快把 firefox 玩死了)。因此之前一直没有成功。Ubuntu 用户太多导致软件适配倾向于 GNOME 桌面，<s>但是真的好丑啊 GNOME</s>。</p><blockquote><p>小贴士：一般桌面 app 不吃 env variable 这一套</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;配置 firefox 系统代理时出现了一些问题，然后查了下 Linux 桌面系统代理的原理，记录一下&lt;/p&gt;
&lt;p&gt;系统信息:&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Proxy" scheme="http://blog.vollate.top/tags/Proxy/"/>
    
    <category term="Linux" scheme="http://blog.vollate.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VPS 测试脚本整理</title>
    <link href="http://blog.vollate.top/2023/12/13/vps-testscripts/"/>
    <id>http://blog.vollate.top/2023/12/13/vps-testscripts/</id>
    <published>2023-12-13T07:44:50.000Z</published>
    <updated>2024-05-10T18:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/117547388">知乎</a></p><h2 id="基础测试-IO-网速">基础测试(IO+网速)</h2><h3 id="Bench">Bench</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO- bench.sh | bash</span><br><span class="line">curl -Lso- bench.sh | bash</span><br><span class="line">wget -qO- 86.re/bench.sh | bash</span><br><span class="line">curl -so- 86.re/bench.sh | bash</span><br></pre></td></tr></table></figure><h3 id="SuperBench">SuperBench</h3><p>会安装较多东西，测得也较全，并且网络测速注重回国速度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO- --no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superbench.sh | bash</span><br><span class="line">curl -Lso- -no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superb</span><br></pre></td></tr></table></figure><h3 id="Superseed">Superseed</h3><p>提供测试全国各地三大运营商速度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh &amp;&amp; chmod +x superspeed.sh &amp;&amp; ./superspeed.sh</span><br></pre></td></tr></table></figure><h3 id="UnixBench">UnixBench</h3><p>主要测试项目有：系统调用、读写、进程、图形化测试、2D、3D、管道、运算、C库等系统基准性能提供测试数据，<a href="https://github.com/teddysun/across?tab=readme-ov-file">发布页</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/unixbench.sh</span><br><span class="line">chmod +x unixbench.sh</span><br><span class="line">./unixbench.sh</span><br></pre></td></tr></table></figure><h3 id="Memory-Test">Memory Test</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">CentOS / RHEL</span></span><br><span class="line">yum install wget -y</span><br><span class="line">yum groupinstall &quot;Development Tools&quot; -y</span><br><span class="line">wget https://raw.githubusercontent.com/FunctionClub/Memtester/master/memtester.cpp</span><br><span class="line">gcc -l stdc++ memtester.cpp</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Ubuntu / Debian</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install wget build-essential -y</span><br><span class="line">wget https://raw.githubusercontent.com/FunctionClub/Memtester/master/memtester.cpp</span><br><span class="line">gcc -l stdc++ memtester.cpp</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/117547388&quot;&gt;知乎&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础测试-IO-网速&quot;&gt;基础测试(IO+网速)&lt;/h2&gt;
&lt;h3 id=&quot;Bench&quot;&gt;Bench&lt;/h3&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Server" scheme="http://blog.vollate.top/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>编译之法</title>
    <link href="http://blog.vollate.top/2023/12/08/compile-knowledge/"/>
    <id>http://blog.vollate.top/2023/12/08/compile-knowledge/</id>
    <published>2023-12-08T07:34:57.000Z</published>
    <updated>2024-10-13T10:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>以 C/C++ 为例，简单介绍一下 Linux 下编译的相关知识。看完应该能掌握基础的编译能力，处理报错不再抓瞎。 <s>麻麻再也不用担心我遇到问题只能瞎逛 stackoverflow 了</s> 该逛还得逛</p><h2 id="基础知识">基础知识</h2><h3 id="编译型语言与解释型语言">编译型语言与解释型语言</h3><ul><li>编译型语言是将代码直接编译成机器可以直接执行的机器码，可以直接在目标机器上执行。代表是 Fortran, C, C++, RUST, Go 等。</li><li>解释型语言是通过解释器逐行解释每条命令来执行对应的操作，运行不需要编译，但是需要对应的解释器解释成对应架构的指令。代表是 Python, ECMAScript, PHP 等等。</li><li>也还有一些两者兼具的，如 JAVA，编译成字节码，然后由 JVM 解释执行。</li></ul><h3 id="汇编语言">汇编语言</h3><p>汇编语言是最接近于机器码的语言，和目标机器的指令集架构紧密相关也称为低级语言。指令集是一种抽象，它将计算机的物理实现抽象成指令集规定的一系列操作，使得同一架构的不同型号计算机能运算同一个程序，且规定了程序如何操作硬件完成计算。汇编之所以成为最接近于机器码的语言，是在于它只需要进行简单的替换就能生成对应的机器码。</p><p>举个 MIPS32 架构汇编的例子：</p><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span>$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span></span><br></pre></td></tr></table></figure><p>这条指令将2和3号寄存器的值相加存储到1号寄存器中，根据 MIPS32 的转换规则，生成的二进制机器码如下:</p><table><thead><tr><th>opcode</th><th>rs</th><th>rt</th><th>rd</th><th>shamt</th><th>func</th></tr></thead><tbody><tr><td>000000</td><td>00010</td><td>00011</td><td>00001</td><td>00000</td><td>100000</td></tr></tbody></table><ul><li>操作码（opcode）：对于 add 操作，它的操作码是 000000。</li><li>源寄存器2（rs）：$2 对应的寄存器是 00010。</li><li>源寄存器3（rt）：$3 对应的寄存器是 00011。</li><li>目标寄存器（rd）：$1 对应的寄存器是 00001。</li><li>移位量（shamt）：对于 add 操作而言，不涉及移位，因此为 00000。</li><li>功能码（funct）：add 操作的功能码是 100000。</li></ul><p>汇编语言经过简单的处理就可以直接转换为机器码，但是有许多坏处:</p><ol><li>可读性差。以下是一个 clang 生成的简单的 hello world 程序的汇编代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .file   &quot;test.c&quot;</span><br><span class="line">    .globl  main                            # -- Begin function main</span><br><span class="line">    .p2align    4, 0x90</span><br><span class="line">    .type   main,@function</span><br><span class="line">main:                                   # @main</span><br><span class="line">    .cfi_startproc</span><br><span class="line"># %bb.0:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset %rbp, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $0, -4(%rbp)</span><br><span class="line">    leaq    .L.str(%rip), %rdi</span><br><span class="line">    movb    $0, %al</span><br><span class="line">    callq   printf@PLT</span><br><span class="line">    xorl    %eax, %eax</span><br><span class="line">    addq    $16, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa %rsp, 8</span><br><span class="line">    retq</span><br><span class="line">.Lfunc_end0:</span><br><span class="line">    .size   main, .Lfunc_end0-main</span><br><span class="line">    .cfi_endproc</span><br><span class="line">                                        # -- End function</span><br><span class="line">    .type   .L.str,@object                  # @.str</span><br><span class="line">    .section    .rodata.str1.1,&quot;aMS&quot;,@progbits,1</span><br><span class="line">.L.str:</span><br><span class="line">    .asciz  &quot;Hello, World!\n&quot;</span><br><span class="line">    .size   .L.str, 15</span><br><span class="line"></span><br><span class="line">    .ident  &quot;clang version 16.0.6&quot;</span><br><span class="line">    .section    &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</span><br><span class="line">    .addrsig</span><br><span class="line">    .addrsig_sym printf</span><br></pre></td></tr></table></figure><p>汇编中没有我们常用的控制流，需要手写判断跳转的操作<br>2. 可移植性差，只使用于特定架构的计算机。如果你想要你的汇编程序同时在 arm64 和 x86_64 上运行，你需要写两份代码。<br>3. 其他就不一一列举了……</p><h3 id="函数声明和定义">函数声明和定义</h3><p>在编程中，我们用函数来表示一种特定的操作，它能够处理我们的输入并且产生对应的输出(副作用)。想深入了解可以看看<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">λ演算</a>，这里就不过多介绍了。函数能够简化我们的代码，对于需要在多处重复执行的操作，我们通过将他包装成函数来简化我们的代码。<br>函数的声明就是告诉编译器我们有这么一个叫xxx的函数，它的输入和输出都是什么类型。定义则是具体描述了函数如何处理输入最终得到输出。</p><p>在编程中，函数往往是声明和定义分开，来将逻辑和函数解耦。在 C/C++ 中，我们通常使用 <code>#include</code> 预处理命令来引用头文件，头文件中包含了函数声明。预处理器会直接将被 include 的文件内容复制到预处理后的文件对应位置中。</p><h3 id="编译过程">编译过程</h3><p>编译器是一种计算机程序，它会将某种编程语言写成的源代码转换成另一种编程语言。主要用途是将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为目标机器能解读、运行的低阶机器语言的程序。将高级语言转化为低级语言的过程称为编译，反过来成为反编译。</p><p>一般编译的过程分为如下步骤:</p><ul><li>预处理: 进行文本替换等其他操作，如 C/C++ 里 “#xxx” 预处理命令的展开以及宏的替换</li><li>编译：将源代码转换为对应架构的汇编代码，生成<code>.s</code>汇编文件</li><li>汇编：将上一步生成的汇编代码翻译成二进制机器码，生成<code>.o</code> object 文件</li><li>链接：将上一步生成的文件和所需要的静态/动态库链接为一个新的 object 文件</li></ul><p>注意不是所有语言的编译都有上述的几个部分，如 JAVA 。</p><h3 id="静态链接和动态链接">静态链接和动态链接</h3><p>我们可以通过声明让在多个地方使用函数而只需提供一次定义，同理，多个文件可以共用同一个函数，只需要链接包含了函数定义的 library 即可，无需重复编译。链接方式有如下两种:</p><ul><li>静态链接：将被链接的库的所有代码嵌入到新的可执行文件或目标文件中。<ul><li>优点：生成的可执行文件不需要依赖外部库</li><li>缺点：<ol><li>生成文件变大</li><li>如果被链接的库更新，需要重新编译</li><li>无法重复利用共享库</li></ol></li></ul></li><li>动态链接：在程序运行时或运行前的装载阶段将外部库代码加载到内存中的过程。可执行文件只包含对这些库的引用，不包含实际的库代码<ul><li>优点：<ol><li>可执行文件可以更小</li><li>多个可执行文件可以复用同一个 lib</li><li>如果更新不改变函数接口，则无需重新编译</li></ol></li><li>缺点：<ol><li>会依赖外部库，如 linux 的 glibc。如果版本不兼容，运行时会报错。</li><li>启动时会略微增加时间</li></ol></li></ul></li></ul><p>动态链接库 <code>.dll</code> (Dynamic link library)是 Windows 下的的称呼，在 Unix/Linux 下称为 Shared Object <code>.so</code>，本文会统一叫动态链接库(叫顺口了)。</p><p>Linux 下，静态链接库一般以 <code>.a</code> 结尾 (archive)</p><hr><h2 id="gcc-clang-使用">gcc/clang 使用</h2><p>本章主要介绍在命令行中使用 gcc/clang 进行编译的的过程和注意事项，以下命令中的 clang 都可以换成 gcc。但是注意，不同编译器所支持的编译参数并不完全相同，因此项目中需要对不同的编译器进行不同参数的适配。</p><ul><li>获取帮助 <code>man clang</code>，man 是 Linux 下的一个 reference 页面，安装的程序可以以一定格式提供 manual 供 man 命令调用。man 使用 vim 的键位，按 / 建开始搜索，n 建下一个，N 键上一个，按 q 键退出。你可以使用 <code>man man</code> 来查看 man 的 manual，如果你只想获得简单的帮助，请使用 <code>clang --help</code></li><li>编译一个文件，生成可执行文件<br><a href="test.c">test.c</a></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang test.c -o test</span><br></pre></td></tr></table></figure><p>注意，在 clang/gcc 默认使用 “main” 作为主函数的入点，如果你的文件中没有 main 函数，编译会报错，因为编译器没有找到主函数入口。这里我们使用 “-o” 指定输出文件名称，如果不指定，默认为 “a.out”</p><ul><li>编译一个库<br><a href="mBool.c">mBool.c</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">static lib</span></span><br><span class="line">clang -c mBool.c -o mBool.o # 这里不写默认生成同名后缀为.o的对应文件</span><br><span class="line">ar r mBool.a mBool.o        # for GNU toolchain</span><br><span class="line">llvm-ar r libmBool.a mBool.o   # for llvm toolchain</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ar 将所有(这里只有一个) .o 文件打包，并创建一个索引表以供查找。某些情况，会选择性对文件进行压缩</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shared lib</span></span><br><span class="line">clang -shared mBool.c -o libmBool.so -fPIC</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上述动态链接库的编译过程中使用了 `-fPIC` 这个参数，意味着生成 position independent code，这样我们的动态链接库就可以在任意地址被装载。</span></span><br></pre></td></tr></table></figure><ul><li>链接一个库<br><a href="mBoolTest.c">mBoolTest.c</a>  这里我懒得写头文件了，直接前置声明了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">link</span> the static lib</span></span><br><span class="line">clang -o mTest.out mBoolTest.c `pwd`/mBool.a</span><br><span class="line">clang -o mTest.out -static mBoolTest.c -L`pwd` -lmBool      # if no shared lib, &quot;-static&quot; is uneeded</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">link</span> the shared lib</span></span><br><span class="line">clang -o mTest.out mBoolTest.c -L`pwd` -lmBool</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ref:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -L<span class="variable">$&#123;target_lib_path&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -l<span class="variable">$&#123;lib_name&#125;</span>            <span class="comment"># compiler will try to find lib$&#123;lib_name&#125;.a/so</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -l:<span class="variable">$&#123;custom_lib_name&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -static                  <span class="comment"># use static link</span></span></span><br></pre></td></tr></table></figure><p>对于静态链接库，我们直接将其作为输入即可链接，因为其本质上就是一个编译后生成的二进制文件 <code>.o</code></p><p>对于动态链接库，编译器会有一些系统默认的动态库目录，它会进入目录下查找。显然我们当前的文件夹并不在此之列，因此为了让编译器进入我们当前的目录下查找链接库，我们使用 <code>-L</code> 来加入我们库所在的目录来让编译器查找。我们之前将编译出来的库命名为 “libmBool.*”，因此可以直接使用 <code>-l</code> 来链接我们的库。因为我们的目录下同时存在静态和动态链接库，因此编译器默认使用动态链接。我们可以使用 <code>-static</code> 来让编译器使用静态链接库。</p><ul><li>使用 -rpath/-runpath<br>现在我们尝试运行我们刚刚链接完动态链接库的可执行文件，然后就报错了</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./mTest.out: error while loading shared libraries: libmBool.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>系统提示我们找不到动态链接库。因为我们没有存储动态链接库的位置，动态链接器(如 ld-linux.so)不知道去哪加载我们的动态链接库我们使用 <code>-rpath</code> 来存储动态链接库的目录信息。可以使用绝对路径或相对路径，一般使用相对路径，这样程序只要保持文件内的结构不变即可在各处执行。注意，这个参数是加给链接器的，clang 可以直接传递给链接器，但是 gcc 需要使用 <code>-Wl</code> 来传递给链接器。<code>runpath</code> 和 <code>rpath</code> 相比，更新，一些老旧的动态链接器可能不支持，但是提供了更多的灵活性，具体下面会讲到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use relative path</span></span><br><span class="line">clang -o mTest.out  mBoolTest.c -L`pwd` -lmBool -rpath . # clang could ignore the -Wl for rpath, but gcc can&#x27;t</span><br><span class="line">clang -o mTest.out  mBoolTest.c -L`pwd` -lmBool -Wl,-rpath . # also works</span><br><span class="line">gcc -o mTest.out  mBoolTest.c -L`pwd` -lmBool -Wl,-rpath .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use absolute path</span></span><br><span class="line">clang -o mTest.out  mBoolTest.c -L`pwd` -lmBool -rpath `pwd`</span><br><span class="line">clang -o mTest.out  mBoolTest.c -L`pwd` -lmBool -Wl,-rpath `pwd`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use runpath</span></span><br><span class="line">clang -o mTest.out  mBoolTest.c -L`pwd` -lmBool -Wl,--enable-new-dtags -Wl,-rpath . # gcc paremeter is the same</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force use rpath(<span class="built_in">disable</span> runpath)</span></span><br><span class="line">clang -o mTest.out  mBoolTest.c -L`pwd` -lmBool -Wl,-rpath . -Wl,--disable-new-dtags</span><br></pre></td></tr></table></figure><ul><li>引用头文件<br>现在我们不偷懒了，引入一个头文件 <a href="head.h">head.h</a>，创建一个 <a href="nMBoolTest.c">nMBoolTest.c</a>，假设头文件存储在目录 <code>/tmp</code> 下，我们要让编译器知道我们头文件的位置，使用 <code>-I</code> 选项</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang -o nTest.out nMBoolTest.c -L`pwd` -lmBool -rpath `pwd` -I/tmp</span><br></pre></td></tr></table></figure><ul><li><p>使用环境变量<br>假设我们没有 make，cmake 这样的自动化构建工具，或者有一个复杂无比的 Makefile/CMakeLists.txt，无法轻易更改。我们需要让编译器知道我们自定义的 header 和 lib 的位置，这时候就需要我们的环境变量登场了。下面介绍一些常用的，更多的看对应编译器的文档，<a href="https://gcc.gnu.org/onlinedocs/gcc/Environment-Variables.html">GCC</a></p></li><li><p>C_INCLUDE_PATH：阅读理解（</p></li><li><p>C_PATH：same as above</p></li><li><p>CPLUS_INCLUDE_PATH：阅读理解（</p></li><li><p>LIBRARY_PATH：告诉链接器库的位置，链接时会进入该目录搜索</p></li><li><p>LD_LIBRARY_PATH: 告诉动态链接器库的位置，运行时会进入该目录搜索</p></li></ul><p>以上写法写法同 <code>PATH</code>，用 <code>:</code> 分隔每个路径</p><p><a href="http://ld.so">ld.so</a>(动态链接器) 搜索顺序:</p><ol><li>编译时设置的 rpath 路径</li><li>环境变量 LD_LIBRARY_PATH</li><li>编译时设置的 runpath: runpath 的搜索优先级低于 LD_LIBRARY_PATH，因此它可以允许用户设置 LD_LIBRARY_PATH 来覆盖 runpath 指定的库，提供更多的灵活性。而 rpath 则不行。当然，这也意味着有可能会无意间使用不同版本的库，造成一些问题。</li><li>缓存文件(如 /etc/ld.so.cache): 包含了当前环境中可用库的索引，可以使用 <code>ldconfig</code> 来更新</li><li>默认路径，如 “/lib”, “/usr/lib” 等等</li></ol><ul><li>常用编译选项:<ul><li><code>-g</code>: generate debug info</li><li><code>-O0, -O1, -O3, -Ofast</code>: 设置编译器优化等级，等级越高优化越多。O0无优化，Ofast 启用O3的同时使用一些不符合 ISO 标准的优化</li><li><code>-v</code>：输出执行的命令</li><li><code>-x</code>：显示指定语言类型</li><li><code>-std=</code>：指定语言标准</li><li><code>-Wall</code>：启用几乎所有 warning</li><li><code>-Werror</code>: 将所有 warning 当作 error</li><li><code>-Wno-deprecated</code>：如果使用了编译器被弃用的功能，不要产生 warning</li><li><code>-Wno-deprecated-declarations</code>：不要对使用 C++ 中的 [[deprecated]] 修饰的对象产生 warning</li><li><code>-mx32</code>：生成32位x86代码</li><li><code>-stdlib=</code>：指定使用的标准库</li><li><code>-E</code>：只进行预处理</li><li><code>-S</code>：生成汇编代码后停止</li><li><code>-c</code>：编译或汇编对象文件，但不链接</li><li>more: read the manual</li></ul></li></ul><h2 id="常见问题解决">常见问题解决</h2><ul><li>报错了：学会看报错，报错是帮你解决问题的，看不懂把报错扔搜索引擎上多半能出来(注意不要复制过多本地环境的无效信息)</li><li>心态崩了：缓上个半天继续整</li></ul><p><img src="fix_all.jpg" alt="fix_all"></p><h2 id="完">完</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以 C/C++ 为例，简单介绍一下 Linux 下编译的相关知识。看完应该能掌握基础的编译能力，处理报错不再抓瞎。 &lt;s&gt;麻麻再也不用担心我遇到问题只能瞎逛 stackoverflow 了&lt;/s&gt; 该逛还得逛&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="Knowledge" scheme="http://blog.vollate.top/categories/Knowledge/"/>
    
    
    <category term="Compiler" scheme="http://blog.vollate.top/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>浅记系统虚拟化</title>
    <link href="http://blog.vollate.top/2023/11/17/virtualization/"/>
    <id>http://blog.vollate.top/2023/11/17/virtualization/</id>
    <published>2023-11-17T11:24:06.000Z</published>
    <updated>2024-05-10T18:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于项目需要学习虚拟化的知识，于是在师兄的建议下读了 sjtu 出的新书<a href="https://ipads.se.sjtu.edu.cn/ospi/">《操作系统原理与实践》</a>中的系统虚拟化的部分，随便记点笔记。</p><p><strong>虚拟化发展历史:</strong></p><ul><li>1960s出现分时操作系统概念。同时期IBM进行了另一个方向也就是虚拟化的探索，并在1968年的system360上实现了第一个VMM(Virtual Machine Monitor) <em>CP/CMS</em></li><li>1980s，开始出现纯软件实现的虚拟机监视器</li><li>1990s, 互联网兴起，web服务器逐渐性能过剩</li><li>1998年，VMware成立。</li><li>云计算兴起，虚拟化越发重要</li></ul><p><strong>优势:</strong></p><ul><li>充分利用服务器性能，<s>搞超售</s></li><li>虚拟机管理更为便捷，可以快速部署销毁</li><li>可以热迁移</li><li>VMI (Virtual Machine Introspection 虚拟机自省)可以从外部检查虚拟机是否被入侵</li></ul><h2 id="系统虚拟化概述">系统虚拟化概述</h2><h3 id="组成部分">组成部分</h3><ul><li>CPU 虚拟化（vCPU）：若虚拟化的指令集和物理架构指令集相同，除了部分特殊指令其他都可以直接执行，效率较高（KVM）；若架构不同，则需要全部转译执行。</li><li>内存虚拟化：引入虚拟物理地址，内存访问需要多经过一层虚拟物理地址到物理地址的映射操作。</li><li>I/O 虚拟化：VMM 提供虚拟驱动供虚拟机使用，并将操作转化为实际的物理设备访问或其他操作。</li></ul><h3 id="VMM-类型">VMM 类型</h3><ul><li>半虚拟化: 运行在最高权限级别，相当于一个以OS作为进程的操作系统，如 Xen。</li><li>完全虚拟化：作为一个进程运行在 OS 上，复用宿主OS的线程调度和资源管理，如 QEMU。</li></ul><h2 id="Trap-Emulate（下陷-模拟）">Trap-Emulate（下陷-模拟）</h2><p>Trap：将系统级ISA拦截转由 VMM 进行模拟操作。如系统调用先转化为虚拟机内核态，然后由 VMM 拦截并完成对应调用的模拟。</p><p>Emulate：用软件模拟执行后的副作用</p><p><strong>基础概念:</strong></p><ul><li>CPU 上下文：指CPU在执行特定进程或任务时所需的信息集合。一般包括该CPU的所有寄存器（包括PC）的值和当前系统状态（内存信息，调度优先级等）。</li><li>中断向量表（Interrupt Vector Table）：存放中断处理函数。</li><li>中断处理过程：触发中断时，首先检查中断是否开启。若开启，CPU 接收中断信号并暂停当前程序处理。然后保存当前上下文以供恢复。然后确定中断类型并从中断向量表中查找对应处理函数的地址并跳转执行。执行结束后，恢复中断前的上下文。</li><li>用户态：用户态是普通应用程序运行的模式。该模式下，程序对硬件的访问受限，一般通过OS提供系统调用切换到内核态来执行对应函数进行访问。</li><li>内核态：OS 一般运行在该状态下。该状态下，OS 能够完全访问并操作硬件，访问所有内存。</li></ul><h3 id="Trap-Emulate-虚拟化实现">Trap-Emulate 虚拟化实现</h3><p>VMM 需提供数据结构，来存储原本存储在物理 CPU 上的所有进程上下文信息，以及对应的其它信息（如中断向量表,虚拟页表等）。</p><ul><li>处理中断：对于硬件中断，将会触发 VMM 查看虚拟机是否开启对应中断。如开启，虚拟机保存上下文后下陷到 VMM，然后 VMM 检查中断向量表处理中断。</li><li>处理系统调用：同中断处理的模式，只是 VMM 需要隔离用户态和内核态的页表映射</li><li>处理线程切换：本质软件中断到内核态然后进行线程调度，切换进程上下文即可。</li><li>多 CPU 模拟：加个数据结构存进程上下文和 vCPU 的对应关系就行。vCPU 调度参考 OS 的进程调度，或者直接用线程 OS 进程来实现。</li></ul><h2 id="CPU虚拟化">CPU虚拟化</h2><p>特权指令：在用户态执行时会下陷进入特权级的指令</p><p>敏感指令：管理物理硬件资源或更改CPU状态的指令</p><p>eg：</p><ul><li>x86 修改 CR 寄存器的值</li><li>读写敏感内存</li><li>I/O 指令</li></ul><h3 id="可虚拟化和不可虚拟化架构">可虚拟化和不可虚拟化架构</h3><p>所有满足敏感指令都是特权指令的架构称为可虚拟化架构，反之则为不可虚拟化架构。</p><p>eg:</p><ul><li>AArch32</li><li>早期 x86</li></ul><h3 id="弥补不可虚拟化架构的方法">弥补不可虚拟化架构的方法</h3><h4 id="全虚拟化">全虚拟化</h4><p><em>适用于无需修改客户端源码的情况</em></p><ul><li>解释执行：用纯软件模拟cpu执行指令过程。具体操作是对于每条指令调用对应的用于模拟的函数，整个过程不产生任何下陷。优点是可以模拟任何 ISA 类型的虚拟机。缺点显而易见，效率低下。</li><li>动态二进制编译：在解释执行的基础上将程序划分为只有一个入口和一个出口,中间无任何修改控制流指令的代码块(相当于创建了一个函数)。第一次执行该块时进行翻译并缓存，之后再执行时调用之前的缓存。翻译替换所有敏感指令，在块的末尾添加一条跳转指令来通知 VMM 执行完毕。</li><li>扫描-翻译：用于虚拟机架构和宿主相同的情况，在程序执行前扫描可能存在敏感指令的代码，翻译并缓存翻译后的代码以便下次复用。大多数情况敏感指令只存在于 OS kernal 中，可以只扫描内核代码。</li></ul><h4 id="半虚拟化">半虚拟化</h4><blockquote><p>在允许修改虚拟机客户端代码的情况下可以使用</p></blockquote><p>原理：通过 VMM 提供的类似系统调用的服务使得虚拟机内核不再需要下陷模拟，而是类似进程使用系统调用一样进行对应操作，效率更高。半虚拟化使得 VMM 获得查看客户端内存分布的能力，能够更合理的分配资源。</p><h4 id="硬件虚拟化">硬件虚拟化</h4><p>通过 CPU 硬件支持来实现更高效的虚拟化。具体来说就是增加一个专为 VMM 运行的特权级，该特权级下 VMM 拥有和宿主 OS 相同的硬件访问权限，来节省下陷的开销。</p><p>拓展——KVM (kernal-based virtual machine) 技术: 通过将 VMM 作为内核模块加载使得 VMM 能够使用 宿主 OS 内核的功能，这样下陷时某些支持的架构可以消除 KVM 到 OS 内核特权级转换带来的开销。指令无需翻译，直接在硬件上执行，使得虚拟化效率接近直接运行。</p><h2 id="内存虚拟化">内存虚拟化</h2><p>目标：实现虚拟机之间，虚拟机和物理机之间的内存隔离<br>术语：</p><ul><li>GVA: Guest Virtual Address</li><li>GPA: Guest Physical Address</li><li>HPA: Host Physical Address</li></ul><h3 id="影子页表-Shadow-Page-Table">影子页表(Shadow Page Table)</h3><p>复习进程页表的配置&amp;使用：</p><ol><li>调用前 OS 为进程配置一个虚拟地址映射到物理地址的静态页表（相对地址）</li><li>OS 将页表基地址写入对应寄存器以让 MMU 能找到页表</li><li>MMU 解析虚拟地址到物理地址</li></ol><p>内存虚拟化中，VMM 需要根据存储的 GPA 到 HPA 的映射信息并生成一个 GVA 到 HPA 的影子页表。在虚拟机下陷时,将页表基地址替换为影子页表基地址，从而让 MMU 直接解析 GVA。</p><p>VMM 需要监视虚拟机对页表的更改，并对应地修改影子页表。同时为了分隔用户态和内核态，需要分离对应的页表，使得用户态页表中不包含内核态的映射</p><p>缺页处理：</p><ul><li>若为页表项不存在或无权限，VMM 需触发宿主 OS 的缺页中断进行处理</li><li>若为访问权限足够，则需要同步影子页表与虚拟机页表</li></ul><h3 id="直接页表映射">直接页表映射</h3><p>客户端与宿主共用页表。该情况下客户端知道自己处在虚拟环境中，VMM 会告知客户端可以使用的页表范围，方便客户端规划。客户端的页表项被设为只读，修改页表需要使用 VMM 提供的超级调用，该调用会检查对页表的修改是否合法。</p><h3 id="两阶段地址翻译">两阶段地址翻译</h3><p>硬件虚拟化的一部分，需要 CPU 支持使用第二页表将 GPA 转换到 HPA，省去 VMM 手动维护影子页表的步骤。同时可以使用 TLB 来优化解析速度。</p><p>缺页中断处理：</p><ul><li>客户虚拟机缺页：无需下陷，硬件直接调用虚拟机注册的中断函数</li><li>第二阶段页表缺页：下陷，硬件直接调用 VMM 注册的的对应中断函数</li></ul><p>优点：</p><ul><li>不用维护影子页表</li><li>不用为每个进程维护一个页表</li><li>缺页处理更快</li></ul><h3 id="换页和内存气球">换页和内存气球</h3><p>目的：运行时动态调整虚拟机内存大小，<s>内存超售</s></p><p><strong>换页逻辑</strong>：</p><ul><li>保存将要交换的页的 GVA 和 GPA</li><li>交换页内数据到持久化存储设备（硬盘什么的）</li><li>将客户端页表项设为 INVALID</li><li>VMM 重新分配该页</li></ul><p><strong>内存气球(Memory Ballooning)</strong>：在客户端插入一个驱动(<s>内鬼</s>)，该驱动根据 VMM 的要求使用虚拟机的接口申请/释放内存，然后将申请的内存物理地址告诉 VMM 来使用。</p><h2 id="I-O虚拟化">I/O虚拟化</h2><ul><li>限制虚拟机对物理硬件的直接访问</li><li>提供虚拟设备接口</li><li>充分利用I/O</li></ul><h3 id="软件模拟（全虚拟化）">软件模拟（全虚拟化）</h3><p>捕获客户端对虚拟硬件的 MMIO, DMA, 中断，下陷后由 VMM 执行对应操作</p><h3 id="半虚拟化-2">半虚拟化</h3><p>类似全虚拟化，客户端不再使用原生驱动而是前端驱动，用于与 VMM 后端驱动交互。 通过内存共享传递数据，并使用批处理加速，由后端驱动完成和物理硬件的交互。</p><h3 id="设备直通">设备直通</h3><p>让客户端直接管理硬件设备，此时操作对应硬件不会产生任何下陷。为防止 DMA 攻击使用 IOMMU 进行二阶段 GPA 到 HPA 的映射并检查对应权限。</p><p>SR-IOV(single root I/O virtualization):实现硬件层面 IO 虚拟化，避免单一虚拟机独占硬件。通过创建多个 VF （virtual function） 让 VMM 分配给虚拟机使用</p><h2 id="中断虚拟化">中断虚拟化</h2><p>两种中断：</p><ul><li>物理中断：由硬件产生，在非直通情况下由 VMM 处理</li><li>虚拟中断：由 VMM 产生</li></ul><p>解决开关中断下陷的问题：增加可供虚拟机修改中断而无需下陷的虚拟寄存器</p><p>直接向虚拟机发送中断：增加一个中断翻译表，用于将物理中断翻译为虚拟机对应的中断。因此无需再进行下陷。</p><h2 id="QEMU-KVM">QEMU/KVM</h2><p>略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近由于项目需要学习虚拟化的知识，于是在师兄的建议下读了 sjtu 出的新书&lt;a href=&quot;https://ipads.se.sjtu.edu.cn/ospi/&quot;&gt;《操作系统原理与实践》&lt;/a&gt;中的系统虚拟化的部分，随便记点笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟化发展</summary>
      
    
    
    
    <category term="Knowledge" scheme="http://blog.vollate.top/categories/Knowledge/"/>
    
    
    <category term="Notes" scheme="http://blog.vollate.top/tags/Notes/"/>
    
    <category term="OS" scheme="http://blog.vollate.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>折腾网站记录</title>
    <link href="http://blog.vollate.top/2023/11/13/build-site/"/>
    <id>http://blog.vollate.top/2023/11/13/build-site/</id>
    <published>2023-11-13T09:22:25.000Z</published>
    <updated>2024-09-26T04:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>原来的 vps 到期了，不想续费新开了一台，忘了全系统备份。索性 blog 扔到 github page,然后又是一顿折腾。</p><h2 id="Github-Action-样例">Github Action 样例</h2><p>改了改 Hexo 官网的:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="literal">true</span>   </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure><h2 id="Github-Action-禁用-jekyll-build">Github Action 禁用 jekyll build</h2><p>因为要用 <code>peaceiris/actions-gh-pages@v3</code> 进行部署，但是用的 Hexo 且已经在先前的操作编译完成，只需部署到对应分支即可。</p><p><s>一开始不知道 debug 了半天</s> 解决方法在仓库里创建一个<code>.nojekyll</code>文件即可, 这会自动禁用 jekyll build 而只执行 deploy (部署编译好的文件到对应分支)</p><h2 id="使用cf后无限redirect">使用cf后无限redirect</h2><p>在 namesilo 买的域名，突发奇想试试用 Cloudflare 免费计划的域名解析（<s>为了CDN</s>）</p><p>配完后炸了，http 请求返回 301 导致无限 redirect，查了下原因如下：</p><blockquote><p>服务器端使用了强制HTTPS，CloudFlare 的Flexible策略原理是：用户访问时使用HTTPS访问到CF的节点，然后CF通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF就是访客，所以服务器返回的状态都是 301。解决方法很简单，将 SSL 策略设为 Full 或者 Full(strict) 就能解决。</p><footer><strong>Vanish</strong><cite><a href="https://vzone.me/897/">vzone.me/897</a></cite></footer></blockquote><h2 id="不要给网盘套-cf-的-cdn">不要给网盘套 cf 的 cdn</h2><p>cf 的 cdn 有单文件100M 大小限制，为了不被滥用。写 dns 的时候脑子抽了，然后虚空 debug nginx 配置文件。</p><hr><h2 id="上大学上的-jpg"><s><strong>上大学上的.jpg</strong></s></h2><p><img src="fiddle-with-ddl.jpg" alt="ddl fuck you"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原来的 vps 到期了，不想续费新开了一台，忘了全系统备份。索性 blog 扔到 github page,然后又是一顿折腾。&lt;/p&gt;
&lt;h2 id=&quot;Github-Action-样例&quot;&gt;Github Action 样例&lt;/h2&gt;
&lt;p&gt;改了改 Hexo 官网的:&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Journal" scheme="http://blog.vollate.top/categories/Journal/"/>
    
    
    <category term="Blog" scheme="http://blog.vollate.top/tags/Blog/"/>
    
    <category term="CI/CD" scheme="http://blog.vollate.top/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>More Effecitve C++</title>
    <link href="http://blog.vollate.top/2023/11/08/more-effecitve-cpp/"/>
    <id>http://blog.vollate.top/2023/11/08/more-effecitve-cpp/</id>
    <published>2023-11-08T08:21:57.000Z</published>
    <updated>2024-05-10T18:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>不能直接往数组类容器塞多态类，使用指针；一定要引用的情况下（需要<code>operator()</code>）用std::reference</li><li>直接创建数组或用vector,array等容器预先分配大小时调用类的无参(默认)构造函数，因此如果用了explict记得声明无参构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有无参构造函数解法（别用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ex</span>;</span><br><span class="line"><span class="type">void</span>* ptr=<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">10</span>*<span class="built_in">sizeof</span>(Ex));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    <span class="keyword">new</span> (&amp;ptr[i]) <span class="built_in">Ex</span>(...);<span class="comment">//call constructor</span></span><br><span class="line"><span class="comment">//Free memory</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>custom <code>i++&amp;++i</code> for class</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>;</span><br><span class="line"><span class="type">int</span> foo <span class="keyword">operator</span>++();<span class="comment">//++i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> foo <span class="keyword">operator</span>++(<span class="type">int</span>);<span class="comment">//i++</span></span><br></pre></td></tr></table></figure><ul><li>尽可能不重载 <code>&amp;&amp;</code>,<code>||</code> and <code>,</code>，因为不满足短路逻辑</li><li>有关<code>new</code>, <code>new[]</code>,<code>delete</code>,<code>delete[]</code><ul><li>new时，先调用<code>void* operator new(size_t size)</code>分配内存,然后初始化对象并且将<code>void*</code>转型为对应类型指针</li><li>operator new 的一个重载:<code>void* operator new(size_t size, void* loaction)</code> 定位new实现</li><li>delete时，先调用析构函数然后<code>operator delete</code> 释放内存</li><li>对数组:<ul><li>new []调用<code>operator new[]()</code>分配内存,然后为每个对象调用构造函数</li><li>delete[]同理</li></ul></li></ul></li><li>构造函数异常处理(未完全构造函数不会栈解退自动析构):<ul><li>使用try catch进行清理</li><li>防止成员列表初始化const pointer异常导致资源泄漏的方法(未完全构造指针无法使用delete):<ul><li>调用一个basic exception guarantee的函数</li><li>使用RAII类</li></ul></li></ul></li><li>异常<ul><li>异常栈解退时调用析构函数再抛出异常将会导致程序直接终止(call terminate directly kill program)</li><li>异常拷贝时按照静态类型拷贝(派生类的基类引用拷贝为基类)</li><li>异常捕获的支持隐式转型(按指):<ul><li>任何指针to <code>void*</code>(极其不建议用指针)</li><li>派生类转基类</li></ul></li><li>总是按catch先后顺序捕获</li><li>按引用捕获可以实现多态</li></ul></li><li>Improve proformance:<ul><li>lazy evaluation: 返回一个结果的代理类，只有在需要时才进行计算</li><li>lazy copy： 写时复制</li><li>lazy fetch：涉及到数据库的部分</li><li>over-eager evaluation：提前计算并存入缓存，或constexpr编译期计算</li></ul></li><li>临时对象: 仅在按值传递对象或者传递常量引用参数时产生。返回对象时，若直接返回则会拷贝局部对象</li><li>返回值优化: 返回构造函数的参数，这样返回的对象会在返回的作用域构造(编译器优化)</li><li>判断类是否在堆中(为了确定能否调用<code>delete this</code>)：重载<code>operator new,operator new[]</code>,记录返回的指针到一个图中，每次删除前进行查找是否在堆上</li><li>适当使用代理可以简化流程，但是会在隐式转型的地方出错</li><li>类型擦除:使用虚基类(接口)</li><li>double dispatch:(针对不同动态类型的多个object产生不同副作用)<ul><li>虚函数 + RTTI：无封装，可维护性为0</li><li>多重虚函数调用: 类似模板递归展开的手动实现，每次确定一个类型，然后调用下一个虚函数</li><li>手动实现虚函数表</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;不能直接往数组类容器塞多态类，使用指针；一定要引用的情况下（需要&lt;code&gt;operator()&lt;/code&gt;）用std::reference&lt;/li&gt;
&lt;li&gt;直接创建数组或用vector,array等容器预先分配大小时调用类的无参(默认)构造函数，因此如果用</summary>
      
    
    
    
    <category term="Knowledge" scheme="http://blog.vollate.top/categories/Knowledge/"/>
    
    
    <category term="Notes" scheme="http://blog.vollate.top/tags/Notes/"/>
    
    <category term="C++" scheme="http://blog.vollate.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CPP 随笔</title>
    <link href="http://blog.vollate.top/2023/11/03/cpp-essay/"/>
    <id>http://blog.vollate.top/2023/11/03/cpp-essay/</id>
    <published>2023-11-03T03:20:31.000Z</published>
    <updated>2024-05-10T18:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录cpp编程过程中的一些总结</p><h2 id="clang-libstdc-debug-问题">clang + libstdc++ debug 问题</h2><p>众所周知 LLVM 的 <code>libc++</code> 和 GNU 的 <code>libstdc++</code> 是两个不同的标准库实现。虽然使用 clang + libstdc++ 编译也可以使用 LLDB 对程序进行 debug，但是字符串以及一些数据结构如 <code>unordered_map</code> 无法正确显示值。解决方式:</p><ol><li>使用编译选项 “-fstandalone-debug”</li><li>在编译和链接时换为 <code>libc++</code>, cmake 中可以使用 <code>set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;)</code> 来解决。</li></ol><p>cheatsheet: cmake 中切换到 llvm 全套 C++ 工具链</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-stdlib=libc++&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-fuse-ld=lld&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录cpp编程过程中的一些总结&lt;/p&gt;
&lt;h2 id=&quot;clang-libstdc-debug-问题&quot;&gt;clang + libstdc++ debug 问题&lt;/h2&gt;
&lt;p&gt;众所周知 LLVM 的 &lt;code&gt;libc++&lt;/code&gt; 和 GNU 的 &lt;code&gt;libs</summary>
      
    
    
    
    <category term="Knowledge" scheme="http://blog.vollate.top/categories/Knowledge/"/>
    
    
    <category term="Notes" scheme="http://blog.vollate.top/tags/Notes/"/>
    
    <category term="C++" scheme="http://blog.vollate.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++</title>
    <link href="http://blog.vollate.top/2023/10/05/effective-cpp/"/>
    <id>http://blog.vollate.top/2023/10/05/effective-cpp/</id>
    <published>2023-10-05T08:03:48.000Z</published>
    <updated>2024-05-10T18:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了(</p><pre><code>Items from 1 to 55</code></pre><hr><ol><li><p>将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择不同的编程方式</p></li><li><p>能用const，enum，inline就别#define</p></li><li><p>能用const就用const</p></li><li><p>确保类初始化后再使用</p><ul><li>尽可能使用列表初始化(原因:operator= first call class’s default consturctor to allocate memory and get address, then do variable assigment)</li><li>避免初始化顺序问题（有关static初始化的问题）</li></ul></li><li><p>知道默认构造，析构，复制构造函数</p><ul><li>一旦创建移动构造||移动赋值操作符，不会生成默认复制构造&amp;&amp;复制运算符，反之亦然</li></ul></li><li><p>小心使用默认生成的类函数</p></li><li><p>若要使用多态，则应将基类析构函数定义为virtual</p></li><li><p>不要让异常离开析构函数</p></li><li><p>不要在构造和析构函数中调用虚函数</p><ul><li>也不是不能用，注意用的时候的类型是基类还是派生类（容易出问题所以不建议用）</li></ul></li><li><p>重载运算符建议返回*this以便连等及其它操作</p></li><li><p>重载操作符时要考虑自己对自己操作的情况</p><ul><li>处理方法：<ol><li>先判断地址</li><li>拷贝后操作拷贝</li></ol></li></ul></li><li><p>拷贝（复制运算符）要完全复制类的内容（包括基类的）</p><ul><li>要复用代码，不要相互调用复制构造函数，而是共同调用一个三方函数</li></ul></li><li><p>RAII: use class to manage resource(<code>unique_ptr &amp; share_ptr</code>)</p></li><li><p>RAII object have specified copy function</p></li><li><p>访问RAII class数据：</p><ul><li>隐式：更方便</li><li>显示：更安全</li></ul></li><li><p>成对使用对应的 <code>new([])</code> &amp; <code>delete([])</code></p></li><li><p>单独创建智能指针<br><code>eg: A(std::unique_ptr&lt;B&gt;(new B), fuc())</code></p><ul><li>智能指针创建需要接受 <code>new</code> 返回的地址，而类构造函数执行顺序由编译器决定，如果<code>fuc</code> throw exception,会导致内存泄漏</li></ul></li><li><p>设计良好的interface</p><ul><li>尽可能不让用户写出出错代码</li><li>减少用户碰到管理内存的几率</li><li>shared_ptr总是使用指向类的析构函数，可以防止cross-DLL(object creat in a dynamic link library but delete in a differet DLL)</li></ul></li><li><p>定义类就是定义类型，关注一些细节</p></li><li><p>尽量传const&amp;,对基础类型直接传值(iterator实现是指针，也算)</p></li><li><p>不要返回指向本地临时变量的指针</p></li><li><p>对用户隐藏数据，protected没比public包装好到哪去</p></li><li><p>不用访问data的就别搞成成员函数</p></li><li><p>类型转换需要非成员函数(<code>friend</code>)</p></li><li><p>创建合适的swap函数：</p><ul><li>默认的std::swap执行三次拷贝构造-&gt;解决方案：构造wapper类使用指针来存储数据，交换仅交换指针，并且提供public的swap成员函数</li><li>如果该类不是模板类，需要具体化std::swap给该类;如果该类是模板类则在namespace中重写swap（模板函数）</li><li>调用规则：using <em>+ using std::swap，调用优先级为 模板swap&gt;具体化std::swap&gt;std::swap,因此记得using</em> 和using std::swap</li></ul></li><li><p>尽可能延缓变量的定义（看情况而定）好处：<br>- 避免无用变量构造消耗时间（throw会导致无用<br>- 优化默认构造+复制构造为复制构造</p></li><li><p>尽可能不用cast，尤其dynamic_cast；必须要用，定义函数来隐藏cast（尽量避免用户自己cast）；少用c类型的转型, c++四种cast</p><ul><li>const_cast</li><li>dynamic_cast</li><li>reinterpret_cast</li><li>static_cast<ul><li>static_cast子类转成父类时是产生一个子类中父类的临时拷贝，修改不会映射到原存储</li></ul></li></ul><blockquote><p>cast要小心，搞清楚自己的目的</p></blockquote></li><li><p>尽可能避免返回句柄[引用和指针]</p><ul><li>指向栈中临时变量会寄掉</li></ul></li><li><p>exception safety:</p><ul><li>No resource leak</li><li>No data structures become coorupted</li></ul><p>exception safety function:</p><ol><li>Basic guarantee: after throw, everything in program remain valid</li><li>Strong guarantee: after exception, the program status remain as if the fuction is never called</li><li>Nothrow guarantee: never throw exception(hard to guarantee out of C part in C++)</li></ol><ul><li>Strong guarantee implement: make a copy and modify the copy, then swap them in noexception way(But this need more resource and time, though it’s highly recommand, not always need to provide strong guarantee)</li><li>一般函数需要提供至少要有weak exception guarantee(at least no resource leak)</li></ul></li><li><p>inline function rules:</p><ul><li>limit inline function as small, frequently called functions.</li><li>内联别用模板<br>其它一些东西：<ul><li>一般构造和析构函数不是内联</li><li>能不能内联主要看编译器</li></ul></li></ul></li><li><p>最小化编译依赖关系（通过声明）可以使用：</p><ol><li>handle class</li><li>interface class: increase memory cost for virtual function table<br>编译时只需要重新链接函数就行</li></ol></li><li><p>public inheritance means “is a”(noted that only public do this)</p></li><li><p>继承会隐藏父类（作用域）的变量和函数（当然名称空间也会{使用using解除隐藏</p></li><li><p>pure virtual function; virtual function;non-virtual function; 不要担心虚函数带来的损耗（大多数情况），也不要全是虚函数（一样）</p><ul><li>pure virtual function可以在类外提供实现，如此可以强制子类重写（算是强制注意吧）并减少代码重复</li><li>80~20rule:80% running time spend on 20% code</li></ul></li><li><p>使用none virtual interface idiom 在基类以确保多态在何时调用函数</p><ul><li>使用函数指针成员代替虚函数（好处：可以更改调用的函数(坏处：缺少对非public变量的访问权限</li><li>使用std::function成员代替虚函数</li></ul></li><li><p>重定义非虚函数可能会使得多态出现意想不到的问题(从设计上来说就不应该重定义非虚函数)</p></li><li><p>默认参数值为静态绑定，不同于虚函数的动态绑定，不要在继承中改变默认值</p></li><li><p>has a &amp; implemented in terms of-- composition</p></li><li><p>private inheritance当仅必要时<br>- both private inheritance and composition mean is-implemented-in-terms-of<br>- composition is easy to understand<br>- private inheritance can enable EBO<br>- empty base optomize(EBO):当仅单继承且父类是空类时，子类大小等于数据大小(编译器优化</p></li><li><p>多继承尽量别用，用要考虑virtual</p><ul><li>虚拟继承有损耗（比起单继承</li><li>多继承例子：public interface+private implementation</li></ul></li><li><p>类和模板都支持多态</p><ul><li>对于类，接口是明确的，多态出现在运行时</li><li>对于模板参数，接口是明确且基于合法的表达式的，多态出现在编译时（通过模板初始化和函数重载）</li></ul></li><li><p>typename和class可以互换</p><ul><li>在不清楚的情况下，C++默认把typename(class):😗**看成变量而不是类型，使用 <code>typename</code> 告诉他这是个变量类型</li></ul></li><li><p>访问模板基类函数的三种方法</p><ol><li>使用 <code>this</code> 指针调用</li><li><code>using</code> 指令</li><li><code>base&lt;T&gt;::**</code>直接用</li></ol></li><li><p>模板隐式具体化出的不依赖于模板参数的函数会导致程序膨胀</p><ul><li>若由非类型参数导致，将模板参数换为函数参数或者类成员变量</li><li>若由类型参数导致，可以将数据转化为 无类型指针 <code>eg: static_cast&lt;void*&gt;</code> 然后统一调用</li></ul></li><li><p>在模板类中使用模板成员函数来接受所有合法参数</p><ul><li>eg: 同模板不同具体化类的实例化的复制构造函数和复制运算符</li><li>注意：即使声明了模板复制构造函数，也要声明一般的复制构造函数</li></ul></li><li><p>我不知道他想说明啥</p></li><li><p>特化模板类使其对特定类型使用特定函数</p><ul><li>通过 <code>tyepid()</code> 检查—wrong, can’t compile<ul><li>由于不同的类型支持不同的函数，一些不支持的函数无法被编译（即使<code>if else</code>永远不会进入)编译过程要求所有代码合法</li></ul></li><li>通过和函数重载(编译时)</li></ul></li><li><p>TMP(template metaprogramming)</p><ul><li>将一部分运行时工作放到编译时进行</li></ul></li><li><p>通过 <code>set_new_handler(*new_handler)</code> 自定义new的行为 <code>typedef void (*new_handler)()</code> declear in std, use as <code>std::new_handler</code></p><ul><li>通过连锁调用在失败后尝试其他 <code>handler</code> 分配内存，最后全部失败再throw bad_alloc</li><li>自定义类new的行为: modify <code>void* operator new(std::size)throw(std::bad_alloc)</code> and <code>set_new_handler</code></li><li>C++93前new分配失败会返回0，使用 <code>new(std::nothrow)</code> 来启用这一行为（只作用于内存分配时，初始化相关对象仍可能throw</li></ul></li><li><p>重载new/delete操作符的几种情况</p><ol><li>优化操作速度</li><li>收集内存使用信息</li><li>减少开头和末尾的内存占用</li><li>自定义内存对齐</li><li>将类集束摆放</li><li>其他未列出new行为</li></ol></li><li><p>重载new和delete</p><ul><li>重载new需要一个无限循环来分配内存，并在失败时调用 <code>set_new_handler</code> 或者分配0空间并throw</li><li>对于类类型，应该分配比预期更大空间</li><li>delete对nullptr什么也不做，对类类型应该删除比预期更大空间</li></ul></li><li><p>重写new了记得重写delete，并且不要无意间隐藏了默认的new&amp;delete</p></li><li><p>注意编译警告，也不要过度依赖编译器</p></li><li><p>熟悉标准库，包括</p><ul><li>STL(standard template library)</li><li>Iostream</li><li>Internationlization(like wchar_t,wstring)</li><li>numeric provessing(valarray, complex)</li><li>exception hierarchy</li><li>C89 standard library</li><li>tr1(2005,Technical report 1), add smartPointers,function pointers(tr1::function,std::function now)就是std::expermental::xxx</li></ul></li><li><p>Boost organization and Boost library</p></li></ol><hr><p>This is just a begining, C++ learning will never end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从vimwiki迁移过来的古早笔记,仔细看看发现好多忘了(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Items from 1 to 55
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将cpp看作C，面向对象的cpp，模板和STL四个部分；根据各个部分的不同特性选择</summary>
      
    
    
    
    <category term="Knowledge" scheme="http://blog.vollate.top/categories/Knowledge/"/>
    
    
    <category term="Notes" scheme="http://blog.vollate.top/tags/Notes/"/>
    
    <category term="C++" scheme="http://blog.vollate.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Book List</title>
    <link href="http://blog.vollate.top/2023/08/30/book-list/"/>
    <id>http://blog.vollate.top/2023/08/30/book-list/</id>
    <published>2023-08-30T07:33:26.000Z</published>
    <updated>2024-03-03T10:46:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reading">Reading</h2><ul><li>C++ Currency in Action</li></ul><h2 id="Schedule">Schedule</h2><ul><li>Effective Modern C++</li><li>C++ Templates ed.2</li></ul><h2 id="Stash">Stash</h2><ul><li>Deep learning</li></ul><h2 id="Finished">Finished</h2><table><thead><tr><th>Name</th><th>Finish date</th></tr></thead><tbody><tr><td>C++ Primer Plus</td><td>2021.12</td></tr><tr><td>Effective C++</td><td>2022.7</td></tr><tr><td>1984</td><td>2022.6</td></tr><tr><td>沙丘</td><td>2022.6</td></tr><tr><td>资本论</td><td>2022.8.1</td></tr><tr><td>地铁系列(203[3,5])</td><td>2022.9.25</td></tr><tr><td>More Effective C++</td><td>2023.1.22</td></tr><tr><td>The Fast Guide towards Modern C++</td><td>2023.7.15</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Reading&quot;&gt;Reading&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Currency in Action&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Schedule&quot;&gt;Schedule&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Effective Modern C++&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="Books" scheme="http://blog.vollate.top/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>Tool List</title>
    <link href="http://blog.vollate.top/2023/03/27/tool-list/"/>
    <id>http://blog.vollate.top/2023/03/27/tool-list/</id>
    <published>2023-03-27T00:17:41.000Z</published>
    <updated>2024-07-06T09:56:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收录了Linux下使用的一些工具</p></blockquote><h2 id="Screen-Shot-Recorder">Screen Shot/Recorder</h2><ul><li><a href="https://www.maartenbaert.be/simplescreenrecorder/">SimpleScreenRecorder</a></li><li><a href="https://obsproject.com/">OBS studio</a></li><li><a href="https://flameshot.org/">Flameshot</a></li></ul><h2 id="Cloud-Drive">Cloud Drive</h2><ul><li><a href="https://github.com/abraunegg/onedrive/tree/master">Onedrive</a></li><li><a href="https://github.com/bpozdena/OneDriveGUI">OnedriveGUI</a>: GUI for client above</li><li><a href="https://rclone.org/">Rclone</a>: better than above</li></ul><h2 id="Proxy">Proxy</h2><h3 id="Clash-Client">Clash Client</h3><ul><li><s><a href="https://github.com/Fndroid/clash_for_windows_pkg">cfw</a>(closed-source)</s> 不建议使用</li><li><s><a href="https://github.com/zzzgydi/clash-verge">clash-verge</a>(open-source)</s></li><li><a href="https://github.com/clash-verge-rev/clash-verge-rev">clash verge rev</a>; 因为某些烂人的原因，被铁拳制裁后重生的版本</li></ul><blockquote><p><s>注意 Clash 和 Clash.Meta 是开源软件，clash.Premium 为 Clash 原作者在 Clash 基础上开发的闭源软件，介意误用</s> 只剩 Meta 了且改名了。原神，启动!!!</p></blockquote><h3 id="V2ray-Client">V2ray Client</h3><ul><li><a href="https://github.com/v2rayA/v2rayA">v2rayA</a>(open-source)</li></ul><h2 id="Diagram">Diagram</h2><ul><li><a href="https://app.diagrams.net/">drawio</a></li></ul><h2 id="Office">Office</h2><ul><li><a href="https://github.com/LibreOffice/core">libreoffice</a></li><li><a href="https://github.com/ONLYOFFICE/DesktopEditors">onlyoffice</a></li><li><a href="https://github.com/xournalpp/xournalpp/">xournal++</a> 全平台手写板工具，但是安卓端还很烂</li></ul><h2 id="Resource-Monitor">Resource Monitor</h2><ul><li><a href="https://github.com/aristocratos/btop">btop</a> or <a href="https://github.com/aristocratos/bpytop">bpytop</a></li><li><a href="https://github.com/htop-dev/htop">htop</a></li></ul><h2 id="Diff-Tools">Diff Tools</h2><ul><li><a href="https://gitlab.gnome.org/GNOME/meld">meld</a></li><li><a href="https://kdiff3.sourceforge.net/">kdiff3</a></li></ul><h2 id="Mouse">Mouse</h2><ul><li><a href="https://github.com/libratbag/piper">piper</a> 解决了 LogitechG 系列鼠标在 Linux 下无法设置 DPI，灯光不亮的问题。相当于一个非官方 Logitech G Hub</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;收录了Linux下使用的一些工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Screen-Shot-Recorder&quot;&gt;Screen Shot/Recorder&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.maa</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://blog.vollate.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Article Archive</title>
    <link href="http://blog.vollate.top/2022/11/10/article-archives/"/>
    <id>http://blog.vollate.top/2022/11/10/article-archives/</id>
    <published>2022-11-10T20:10:57.000Z</published>
    <updated>2024-02-15T14:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS">OS</h2><ul><li><a href="https://bbs.huaweicloud.com/blogs/279735">内存管理</a></li></ul><h2 id="Program">Program</h2><ul><li><a href="https://www.foonathan.net/2016/03/cmake-install/">CMake export lib</a></li><li><a href="https://www.cnblogs.com/pcdack/p/16019319.html">oneAPI|DPC++归档</a></li><li><a href="https://www.youtube.com/@CppCon">CppCon</a></li></ul><h2 id="Network">Network</h2><ul><li><a href="https://gfw.report/">GFW report</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OS&quot;&gt;OS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/279735&quot;&gt;内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Program&quot;&gt;Program&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="Archive" scheme="http://blog.vollate.top/tags/Archive/"/>
    
  </entry>
  
</feed>
